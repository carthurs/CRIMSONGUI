#-----------------------------------------------------------------------------
# PythonModules
#
# This script clones the external PythonModules repository from github
# and stores the code in, for example, C:\crimson\rel\PythonModules,
# then it generates some temporary files and does some other setup tasks for
# the python code.
#-----------------------------------------------------------------------------
if( MITK_USE_Python AND NOT MITK_USE_SYSTEM_PYTHON )
  message("Executing PythonModules setup.")

  # Sanity checks
  if(DEFINED PythonModules_DIR AND NOT EXISTS ${PythonModules_DIR})
    message(FATAL_ERROR "PythonModules_DIR variable is defined but corresponds to non-existing directory")
  endif()

  if( NOT DEFINED PythonModules_DIR )
    set(proj PythonModules)


    #[AJM] what's the value of these macro ${}_WHATEVER names? This is a local variable, there's no need to use ${} to make unique names...
    set(${proj}_DEPENDENCIES MITK presolver)

    if(PACKAGE_FLOWSOLVER)
      #[AJM]  do the python modules really ever need the flowsolver as a dependency? I don't think so...
      #       I mean, some of the scripts do technically call the flowsolver, but most of the python scripts can run without it.
      list(APPEND ${proj}_DEPENDENCIES flowsolver)
    endif()

    set(_PythonModules_build_step ${CMAKE_CURRENT_SOURCE_DIR}/CMake/crimsonFunctionExternalPythonBuildStep.cmake)

    # install step
    set(_install_step ${CMAKE_BINARY_DIR}/CMakeExternals/tmp/${proj}_install_step.cmake)
    message("Writing install step file to " ${_install_step})

    #NOTE:  - The indentation below is correct. Avoid putting extra tabs in the string below, they will appear in the generated file.
    #         This generated script copies 
    #
    #       - source_dir for this cmake script is NOT the same as source_dir for PythonModules_configure_setp.cmake
    file(WRITE ${_install_step}
"#NOTE: Script generated by CMake/PythonModules.cmake.
#Where source_dir is e.g., C:/cr/PythonModules; the value of this varaible is only known when the external project runs this via 
#the INSTALL_COMMAND of the PythonModules ExternalProject.

message(\"Executing generated CMake script build/CMakeExternals/tmp/PythonModules_install_step.cmake, source_dir is \${source_dir}\")
include(\"${_PythonModules_build_step}\")

# This pretty much just runs setup.py with the install command
crimsonFunctionExternalPythonBuildStep(${proj} install \"\${source_dir}\" setup.py install --force)
"
       )
      
    # build step
    set(_build_step ${CMAKE_BINARY_DIR}/CMakeExternals/tmp/${proj}_build_step.cmake)
    message("Writing build step file to " ${_build_step})

    #NOTE:  - The indentation below is correct. Avoid putting extra tabs in the string below, they will appear in the generated file.
    #         This generated script copies 
    #
    #       - source_dir for this cmake script is NOT the same as source_dir for PythonModules_configure_setp.cmake
    file(WRITE ${_build_step}
"#NOTE: Script generated by CMake/PythonModules.cmake.
#Where source_dir is e.g., C:/cr/PythonModules; the value of this varaible is only known when the external project runs this via 
#the BUILD_COMMAND of the PythonModules ExternalProject.

message(\"Executing generated CMake script build/CMakeExternals/tmp/PythonModules_build_step.cmake, source_dir is \${source_dir}\")
include(\"${_PythonModules_build_step}\")

# This pretty much just runs setup.py with the build command (which does not build the flowsolver)
# TODO: Figure out what step in the build process generates .pyc files.
crimsonFunctionExternalPythonBuildStep(${proj} build \"\${source_dir}\" setup.py build --force)

message(\"End of build/CMakeExternals/tmp/PythonModules_build_step.cmake\")
"
        )

    # escape spaces
    if(UNIX)
      STRING(REPLACE " " "\ " _install_step ${_install_step})
      STRING(REPLACE " " "\ " _build_step ${_build_step})
    endif()

    set(_configure_step ${CMAKE_BINARY_DIR}/CMakeExternals/tmp/${proj}_configure_step.cmake)

    message("Writing configure step script to " ${_configure_step})
    #NOTE:  - The indentation below is correct. Avoid putting extra tabs in the string below, they will appear in the generated file.
    #         This generated script copies 
    #
    #       - source_dir for this cmake script is NOT the same as source_dir for PythonModules_configure_setp.cmake
    file(WRITE ${_configure_step}
"#NOTE: Script generated by CMake/PythonModules.cmake.
#Where source_dir is e.g., C:/cr/PythonModules; the value of this varaible is only known when the external project runs this via 
#the forceconfigure build step.
#Note also that external projects run configure and build for themselves when the main project is built.
message(\"Executing generated CMake script build/CMakeExternals/tmp/PythonModules_configure_step.cmake, source_dir is \${source_dir}\")
#where flowsolver_folder is e.g., C:/cr/CMakeExternals/Source/flowsolver
file(COPY ${flowsolver_folder} DESTINATION \"\${source_dir}/CRIMSONSolver/SolverStudies/\")

#where presolver_executable is e.g., C:/cr/CMakeExternals/Source/presolver/presolver.exe
file(COPY ${presolver_executable} DESTINATION \"\${source_dir}/CRIMSONSolver/SolverStudies/\")
get_filename_component(presolver_executable_filename ${presolver_executable} NAME)

configure_file(
                \"\${source_dir}/CRIMSONSolver/SolverStudies/PresolverExecutableName.py.in\" 
                \"\${source_dir}/CRIMSONSolver/SolverStudies/PresolverExecutableName.py\"
              )
configure_file(\"\${source_dir}/setup.py.in\" \"\${source_dir}/setup.py\")
message(\"End of build/CMakeExternals/tmp/PythonModules_configure_step.cmake\")
"
      )

    set(python_lib_folder "Lib/")
    if (UNIX)
        set(python_lib_folder "lib/python2.7/")
    endif()

    set(PY_SOURCE_DIR "" CACHE PATH "source code location. If empty, will be cloned from GIT_REPOSITORY")
    set(PY_GIT_REPOSITORY "https://github.com/carthurs/CRIMSONPythonModules.git" CACHE STRING "The git repository for the CRIMSON Python modules")
    set(PY_GIT_TAG "20201101_particles" CACHE STRING "The tag or commit hash of the desired revision of the CRIMSON Python modules")
    
    if(NOT PY_SOURCE_DIR)
      set(py_source_location
          SOURCE_DIR ${CMAKE_BINARY_DIR}/${proj}
          GIT_REPOSITORY ${PY_GIT_REPOSITORY}
          GIT_TAG ${PY_GIT_TAG}
          )
    else()
      set(py_source_location
          SOURCE_DIR ${PY_SOURCE_DIR}
        )
    endif()

    ExternalProject_Add(${proj} # where proj is PythonModules
	  ${py_source_location}
      LIST_SEPARATOR ${sep}
      BUILD_IN_SOURCE 1
      BUILD_ALWAYS 1
      CONFIGURE_COMMAND ""
      BUILD_COMMAND   ${CMAKE_COMMAND} -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR> -Dsource_dir:PATH=<SOURCE_DIR> -DMITK_DIR:PATH=${MITK_DIR} -P ${_build_step}
      INSTALL_COMMAND ${CMAKE_COMMAND} -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR> -Dsource_dir:PATH=<SOURCE_DIR> -DMITK_DIR:PATH=${MITK_DIR} -P ${_install_step}
      DEPENDS
        ${${proj}_DEPENDENCIES}
    )    
    
    ExternalProject_Add_Step(${proj} forceconfigure # where proj is PythonModules
            COMMAND ${CMAKE_COMMAND} -Dsource_dir:PATH=<SOURCE_DIR> -Dpresolver_executable:FILEPATH=${presolver_executable} -Dpython_lib_folder:STRING=${python_lib_folder} -P ${_configure_step}

            DEPENDEES update
            DEPENDERS configure
            ALWAYS 1)

    
    ExternalProject_Get_Property(${proj} source_dir)

       
    set(PythonModules_DIR ${MITK_PYTHON_SITE_DIR}/PythonModules)
    install(SCRIPT ${_install_step})
  else()
    mitkMacroEmptyExternalProject(${proj} "${proj_DEPENDENCIES}")
  endif()
endif()

