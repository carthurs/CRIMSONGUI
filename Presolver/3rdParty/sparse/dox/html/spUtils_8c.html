<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>spUtils.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.17 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>spUtils.c File Reference</h1><code>#include &lt;stdio.h&gt;</code><br>
<code>#include "<a class="el" href="spConfig_8h-source.html">spConfig.h</a>"</code><br>
<code>#include "<a class="el" href="spMatrix_8h-source.html">spMatrix.h</a>"</code><br>
<code>#include "spDefs.h"</code><br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="a0" doxytag="spUtils.c::spINSIDE_SPARSE"></a>
#define&nbsp;</td><td valign=bottom><b>spINSIDE_SPARSE</b></td></tr>
<tr><td nowrap align=right valign=top><a name="a1" doxytag="spUtils.c::NORM"></a>
#define&nbsp;</td><td valign=bottom><b>NORM</b>(a)&nbsp;&nbsp;&nbsp;(nr = ABS((a).Real), ni = ABS((a).Imag), MAX (nr,ni))</td></tr>
<tr><td nowrap align=right valign=top><a name="a2" doxytag="spUtils.c::SLACK"></a>
#define&nbsp;</td><td valign=bottom><b>SLACK</b>&nbsp;&nbsp;&nbsp;1e4</td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a11">spMNA_Preorder</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a12">spScale</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix, spREAL RHS_ScaleFactors[], spREAL SolutionScaleFactors[])</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a14">spMultiply</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix, spREAL RHS[], spREAL Solution[])</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a15">spMultTransposed</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix, spREAL RHS[], spREAL Solution[])</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a16">spDeterminant</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix, int *pExponent, spREAL *pDeterminant, spREAL *piDeterminant)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a17">spStripFills</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a18">spDeleteRowAndCol</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix, int Row, int Col)</td></tr>
<tr><td nowrap align=right valign=top>spREAL&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a19">spPseudoCondition</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix)</td></tr>
<tr><td nowrap align=right valign=top>spREAL&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a20">spCondition</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix, spREAL NormOfMatrix, int *pError)</td></tr>
<tr><td nowrap align=right valign=top>spREAL&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a21">spNorm</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix)</td></tr>
<tr><td nowrap align=right valign=top>spREAL&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a22">spLargestElement</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix)</td></tr>
<tr><td nowrap align=right valign=top>spREAL&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a23">spRoundoff</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix, spREAL Rho)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="spUtils_8c.html#a24">spErrorMessage</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a> eMatrix, FILE *Stream, char *Originator)</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
 This file contains various optional utility routines.
<p>
Objects that begin with the <em>spc</em> prefix are considered private and should not be used.
<p>
<dl compact><dt><b>Author: </b></dt><dd>
 Kenneth S. Kundert &lt;<a href="mailto:kundert@users.sourceforge.net">kundert@users.sourceforge.net</a>&gt;</dl><hr><h2>Function Documentation</h2>
<a name="a20" doxytag="spUtils.c::spCondition"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spREAL spCondition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>NormOfMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pError</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes an estimate of the condition number using a variation on the LINPACK condition number estimation algorithm. This quantity is an indicator of ill-conditioning in the matrix. To avoid problems with overflow, the reciprocal of the condition number is returned. If this number is small, and if the matrix is scaled such that uncertainties in the RHS and the matrix entries are equilibrated, then the matrix is ill-conditioned. If the this number is near one, the matrix is well conditioned. This routine must only be used after a matrix has been factored by <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>() or <a class="el" href="spFactor_8c.html#a25">spFactor</a>() and before it is cleared by <a class="el" href="spBuild_8c.html#a10">spClear</a>() or <a class="el" href="spBuild_8c.html#a21">spInitialize</a>().
<p>
Unlike the LINPACK condition number estimator, this routines returns the L infinity condition number. This is an artifact of Sparse placing ones on the diagonal of the upper triangular matrix rather than the lower. This difference should be of no importance.
<p>
<b>References</b>:
<p>
A.K. Cline, C.B. Moler, G.W. Stewart, J.H. Wilkinson. An estimate for the condition number of a matrix. SIAM Journal on Numerical Analysis. Vol. 16, No. 2, pages 368-375, April 1979.
<p>
J.J. Dongarra, C.B. Moler, J.R. Bunch, G.W. Stewart. LINPACK User's Guide. SIAM, 1979.
<p>
Roger G. Grimes, John G. Lewis. Condition number estimation for sparse matrices. SIAM Journal on Scientific and Statistical Computing. Vol. 2, No. 4, pages 384-388, December 1981.
<p>
Dianne Prost O'Leary. Estimating matrix condition numbers. SIAM Journal on Scientific and Statistical Computing. Vol. 1, No. 2, pages 205-209, June 1980.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 The reciprocal of the condition number. If the matrix was singular, zero is returned.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
<tr><td valign=top><em>NormOfMatrix</em>&nbsp;</td><td>
The L-infinity norm of the unfactored matrix as computed by <a class="el" href="spUtils_8c.html#a21">spNorm</a>(). </td></tr>
<tr><td valign=top><em>pError</em>&nbsp;</td><td>
Used to return error code. Possible errors include <em>spSINGULAR</em> or <em>spNO_MEMORY</em>. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a18" doxytag="spUtils.c::spDeleteRowAndCol"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void spDeleteRowAndCol </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Row</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Col</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a row and a column from a matrix.
<p>
Sparse will abort if an attempt is made to delete a row or column that doesn't exist.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix in which the row and column are to be deleted. </td></tr>
<tr><td valign=top><em>Row</em>&nbsp;</td><td>
Row to be deleted. </td></tr>
<tr><td valign=top><em>Col</em>&nbsp;</td><td>
Column to be deleted. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a16" doxytag="spUtils.c::spDeterminant"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void spDeterminant </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pExponent</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pDeterminant</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piDeterminant</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine in capable of calculating the determinant of the matrix once the LU factorization has been performed. Hence, only use this routine after <a class="el" href="spFactor_8c.html#a25">spFactor</a>() and before <a class="el" href="spBuild_8c.html#a10">spClear</a>(). The determinant equals the product of all the diagonal elements of the lower triangular matrix L, except that this product may need negating. Whether the product or the negative product equals the determinant is determined by the number of row and column interchanges performed. Note that the determinants of matrices can be very large or very small. On large matrices, the determinant can be far larger or smaller than can be represented by a floating point number. For this reason the determinant is scaled to a reasonable value and the logarithm of the scale factor is returned.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
A pointer to the matrix for which the determinant is desired. </td></tr>
<tr><td valign=top><em>pExponent</em>&nbsp;</td><td>
The logarithm base 10 of the scale factor for the determinant. To find the actual determinant, Exponent should be added to the exponent of Determinant. </td></tr>
<tr><td valign=top><em>pDeterminant</em>&nbsp;</td><td>
The real portion of the determinant. This number is scaled to be greater than or equal to 1.0 and less than 10.0. </td></tr>
<tr><td valign=top><em>piDeterminant</em>&nbsp;</td><td>
The imaginary portion of the determinant. When the matrix is real this pointer need not be supplied, nothing will be returned. This number is scaled to be greater than or equal to 1.0 and less than 10.0. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a24" doxytag="spUtils.c::spErrorMessage"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void spErrorMessage </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Stream</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Originator</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine prints a short message describing the error error state of sparse. No message is produced if there is no error. The error state is cleared.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Matrix for which the error message is to be printed. </td></tr>
<tr><td valign=top><em>Stream</em>&nbsp;</td><td>
Stream to which the error message is to be printed. </td></tr>
<tr><td valign=top><em>Originator</em>&nbsp;</td><td>
Name of originator of error message. If NULL, `sparse' is used. If zero-length string, no originator is printed. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a22" doxytag="spUtils.c::spLargestElement"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spREAL spLargestElement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine, along with <a class="el" href="spUtils_8c.html#a23">spRoundoff</a>(), are used to gauge the stability of a factorization. If the factorization is determined to be too unstable, then the matrix should be reordered. The routines compute quantities that are needed in the computation of a bound on the error attributed to any one element in the matrix during the factorization. In other words, there is a matrix <img align="top" src="form_0.png">
 of error terms such that <img align="top" src="form_1.png">
. This routine finds a bound on <img align="top" src="form_2.png">
. Erisman &amp; Reid [1] showed that <img align="top" src="form_3.png">
, where <img align="top" src="form_4.png">
 is the machine rounding unit, <img align="top" src="form_5.png">
 where the max is taken over every row <img align="top" src="form_6.png">
, column <img align="top" src="form_7.png">
, and step <img align="top" src="form_8.png">
, and <img align="top" src="form_9.png">
 is the number of multiplications required in the computation of <img align="top" src="form_10.png">
 if <img align="top" src="form_11.png">
 or <img align="top" src="form_12.png">
 otherwise. Barlow [2] showed that <img align="top" src="form_13.png">
 where <img align="top" src="form_14.png">
.
<p>
<a class="el" href="spUtils_8c.html#a22">spLargestElement</a>() finds the magnitude on the largest element in the matrix. If the matrix has not yet been factored, the largest element is found by direct search. If the matrix is factored, a bound on the largest element in any of the reduced submatrices is computed using Barlow with <img align="top" src="form_15.png">
 and <img align="top" src="form_16.png">
. The ratio of these two numbers is the growth, which can be used to determine if the pivoting order is adequate. A large growth implies that considerable error has been made in the factorization and that it is probably a good idea to reorder the matrix. If a large growth in encountered after using <a class="el" href="spFactor_8c.html#a25">spFactor</a>(), reconstruct the matrix and refactor using <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>(). If a large growth is encountered after using <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>(), refactor using <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>() with the pivot threshold increased, say to 0.1.
<p>
Using only the size of the matrix as an upper bound on <img align="top" src="form_9.png">
 and Barlow's bound, the user can estimate the size of the matrix error terms <img align="top" src="form_17.png">
 using the bound of Erisman and Reid. <a class="el" href="spUtils_8c.html#a23">spRoundoff</a>()  computes a tighter bound (with more work) based on work by Gear [3], <img align="top" src="form_18.png">
 where <img align="top" src="form_19.png">
 is the threshold and <img align="top" src="form_20.png">
 is the maximum number of off-diagonal elements in any row of <img align="top" src="form_21.png">
. The expensive part of computing this bound is determining the maximum number of off-diagonals in <img align="top" src="form_21.png">
, which changes only when the order of the matrix changes. This number is computed and saved, and only recomputed if the matrix is reordered.
<p>
[1] A. M. Erisman, J. K. Reid. Monitoring the stability of the triangular factorization of a sparse matrix. Numerische Mathematik. Vol. 22, No. 3, 1974, pp 183-186.
<p>
[2] J. L. Barlow. A note on monitoring the stability of triangular decomposition of sparse matrices. "SIAM Journal of Scientific and Statistical Computing." Vol. 7, No. 1, January 1986, pp 166-168.
<p>
[3] I. S. Duff, A. M. Erisman, J. K. Reid. "Direct Methods for Sparse Matrices." Oxford 1986. pp 99.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 If matrix is not factored, returns the magnitude of the largest element in the matrix. If the matrix is factored, a bound on the magnitude of the largest element in any of the reduced submatrices is returned.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a11" doxytag="spUtils.c::spMNA_Preorder"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void spMNA_Preorder </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine massages modified node admittance matrices to remove zeros from the diagonal. It takes advantage of the fact that the row and column associated with a zero diagonal usually have structural ones placed symmetricly. This routine should be used only on modified node admittance matrices and should be executed after the matrix has been built but before the factorization begins. It should be executed for the initial factorization only and should be executed before the rows have been linked. Thus it should be run before using <a class="el" href="spUtils_8c.html#a12">spScale</a>(), <a class="el" href="spUtils_8c.html#a14">spMultiply</a>(), <a class="el" href="spUtils_8c.html#a18">spDeleteRowAndCol</a>(), or <a class="el" href="spUtils_8c.html#a21">spNorm</a>().
<p>
This routine exploits the fact that the structural ones are placed in the matrix in symmetric twins. For example, the stamps for grounded and a floating voltage sources are <div class="fragment"><pre>  grounded:              floating:
  [  x   x   1 ]         [  x   x   1 ]
  [  x   x     ]         [  x   x  -1 ]
  [  1         ]         [  1  -1     ]
</pre></div> Notice for the grounded source, there is one set of twins, and for the floating, there are two sets. We remove the zero from the diagonal by swapping the rows associated with a set of twins. For example: <div class="fragment"><pre>  grounded:              floating 1:            floating 2:
  [  1         ]         [  1  -1     ]         [  x   x   1 ]
  [  x   x     ]         [  x   x  -1 ]         [  1  -1     ]
  [  x   x   1 ]         [  x   x   1 ]         [  x   x  -1 ]
</pre></div>
<p>
It is important to deal with any zero diagonals that only have one set of twins before dealing with those that have more than one because swapping row destroys the symmetry of any twins in the rows being swapped, which may limit future moves. Consider <div class="fragment"><pre>  [  x   x   1     ]
  [  x   x  -1   1 ]
  [  1  -1         ]
  [      1         ]
</pre></div> There is one set of twins for diagonal 4 and two for diagonal 3. Dealing with diagonal 4 first requires swapping rows 2 and 4. <div class="fragment"><pre>  [  x   x   1     ]
  [      1         ]
  [  1  -1         ]
  [  x   x  -1   1 ]
</pre></div> We can now deal with diagonal 3 by swapping rows 1 and 3. <div class="fragment"><pre>  [  1  -1         ]
  [      1         ]
  [  x   x   1     ]
  [  x   x  -1   1 ]
</pre></div> And we are done, there are no zeros left on the diagonal. However, if we originally dealt with diagonal 3 first, we could swap rows 2 and 3 <div class="fragment"><pre>  [  x   x   1     ]
  [  1  -1         ]
  [  x   x  -1   1 ]
  [      1         ]
</pre></div> Diagonal 4 no longer has a symmetric twin and we cannot continue.
<p>
So we always take care of lone twins first. When none remain, we choose arbitrarily a set of twins for a diagonal with more than one set and swap the rows corresponding to that twin. We then deal with any lone twins that were created and repeat the procedure until no zero diagonals with symmetric twins remain.
<p>
In this particular implementation, columns are swapped rather than rows. The algorithm used in this function was developed by Ken Kundert and Tom Quarles.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix to be preordered. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a14" doxytag="spUtils.c::spMultiply"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void spMultiply </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RHS</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Solution</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Multiplies matrix by solution vector to find source vector. Assumes matrix has not been factored. This routine can be used as a test to see if solutions are correct. It should not be used before <a class="el" href="spUtils_8c.html#a11">spMNA_Preorder</a>().<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
<tr><td valign=top><em>RHS</em>&nbsp;</td><td>
RHS is the right hand side. This is what is being solved for. </td></tr>
<tr><td valign=top><em>Solution</em>&nbsp;</td><td>
Solution is the vector being multiplied by the matrix. </td></tr>
<tr><td valign=top><em>iRHS</em>&nbsp;</td><td>
iRHS is the imaginary portion of the right hand side. This is what is being solved for. This is only necessary if the matrix is complex and <em>spSEPARATED_COMPLEX_VECTORS</em> is true. </td></tr>
<tr><td valign=top><em>iSolution</em>&nbsp;</td><td>
iSolution is the imaginary portion of the vector being multiplied by the matrix. This is only necessary if the matrix is complex and <em>spSEPARATED_COMPLEX_VECTORS</em> is true. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a15" doxytag="spUtils.c::spMultTransposed"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void spMultTransposed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RHS</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Solution</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Multiplies transposed matrix by solution vector to find source vector. Assumes matrix has not been factored. This routine can be used as a test to see if solutions are correct. It should not be used before <a class="el" href="spUtils_8c.html#a11">spMNA_Preorder</a>().<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
<tr><td valign=top><em>RHS</em>&nbsp;</td><td>
RHS is the right hand side. This is what is being solved for. </td></tr>
<tr><td valign=top><em>Solution</em>&nbsp;</td><td>
Solution is the vector being multiplied by the matrix. </td></tr>
<tr><td valign=top><em>iRHS</em>&nbsp;</td><td>
iRHS is the imaginary portion of the right hand side. This is what is being solved for. This is only necessary if the matrix is complex and <em>spSEPARATED_COMPLEX_VECTORS</em> is true. </td></tr>
<tr><td valign=top><em>iSolution</em>&nbsp;</td><td>
iSolution is the imaginary portion of the vector being multiplied by the matrix. This is only necessary if the matrix is complex and <em>spSEPARATED_COMPLEX_VECTORS</em> is true. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a21" doxytag="spUtils.c::spNorm"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spREAL spNorm </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the L-infinity norm of an unfactored matrix. It is a fatal error to pass this routine a factored matrix.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 The largest absolute row sum of matrix.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a19" doxytag="spUtils.c::spPseudoCondition"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spREAL spPseudoCondition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the magnitude of the ratio of the largest to the smallest pivots. This quantity is an indicator of ill-conditioning in the matrix. If this ratio is large, and if the matrix is scaled such that uncertainties in the RHS and the matrix entries are equilibrated, then the matrix is ill-conditioned. However, a small ratio does not necessarily imply that the matrix is well-conditioned. This routine must only be used after a matrix has been factored by <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>() or <a class="el" href="spFactor_8c.html#a25">spFactor</a>() and before it is cleared by <a class="el" href="spBuild_8c.html#a10">spClear</a>() or <a class="el" href="spBuild_8c.html#a21">spInitialize</a>(). The pseudocondition is faster to compute than the condition number calculated by <a class="el" href="spUtils_8c.html#a20">spCondition</a>(), but is not as informative.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 The magnitude of the ratio of the largest to smallest pivot used during previous factorization. If the matrix was singular, zero is returned.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a23" doxytag="spUtils.c::spRoundoff"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spREAL spRoundoff </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Rho</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine, along with <a class="el" href="spUtils_8c.html#a22">spLargestElement</a>(), are used to gauge the stability of a factorization. See description of <a class="el" href="spUtils_8c.html#a22">spLargestElement</a>() for more information.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 Returns a bound on the magnitude of the largest element in <img align="top" src="form_22.png">
.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
<tr><td valign=top><em>Rho</em>&nbsp;</td><td>
The bound on the magnitude of the largest element in any of the reduced submatrices. This is the number computed by the function <a class="el" href="spUtils_8c.html#a22">spLargestElement</a>() when given a factored matrix. If this number is negative, the bound will be computed automatically. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a12" doxytag="spUtils.c::spScale"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void spScale </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RHS_ScaleFactors</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>SolutionScaleFactors</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function scales the matrix to enhance the possibility of finding a good pivoting order. Note that scaling enhances accuracy of the solution only if it affects the pivoting order, so it makes no sense to scale the matrix before <a class="el" href="spFactor_8c.html#a25">spFactor</a>(). If scaling is desired it should be done before <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>(). There are several things to take into account when choosing the scale factors. First, the scale factors are directly multiplied against the elements in the matrix. To prevent roundoff, each scale factor should be equal to an integer power of the number base of the machine. Since most machines operate in base two, scale factors should be a power of two. Second, the matrix should be scaled such that the matrix of element uncertainties is equilibrated. Third, this function multiplies the scale factors by the elements, so if one row tends to have uncertainties 1000 times smaller than the other rows, then its scale factor should be 1024, not 1/1024. Fourth, to save time, this function does not scale rows or columns if their scale factors are equal to one. Thus, the scale factors should be normalized to the most common scale factor. Rows and columns should be normalized separately. For example, if the size of the matrix is 100 and 10 rows tend to have uncertainties near 1e-6 and the remaining 90 have uncertainties near 1e-12, then the scale factor for the 10 should be 1/1,048,576 and the scale factors for the remaining 90 should be 1. Fifth, since this routine directly operates on the matrix, it is necessary to apply the scale factors to the RHS and Solution vectors. It may be easier to simply use <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>() on a scaled matrix to choose the pivoting order, and then throw away the matrix. Subsequent factorizations, performed with <a class="el" href="spFactor_8c.html#a25">spFactor</a>(), will not need to have the RHS and Solution vectors descaled. Lastly, this function should not be executed before the function <a class="el" href="spUtils_8c.html#a11">spMNA_Preorder</a>().<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix to be scaled. </td></tr>
<tr><td valign=top><em>SolutionScaleFactors</em>&nbsp;</td><td>
The array of Solution scale factors. These factors scale the columns. All scale factors are real valued. </td></tr>
<tr><td valign=top><em>RHS_ScaleFactors</em>&nbsp;</td><td>
The array of RHS scale factors. These factors scale the rows. All scale factors are real valued. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a17" doxytag="spUtils.c::spStripFills"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void spStripFills </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Strips the matrix of all fill-ins.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix to be stripped. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Mon Jun 30 12:01:29 2003 for Sparse by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.17 </small></address>
</body>
</html>
