<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>spMatrix.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.17 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>spMatrix.h File Reference</h1><code>#include "<a class="el" href="spConfig_8h-source.html">spConfig.h</a>"</code><br>

<p>
<a href="spMatrix_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structspTemplate.html">spTemplate</a></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a0">spOKAY</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a1">spSMALL_PIVOT</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a2">spZERO_DIAG</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a3">spSINGULAR</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a4">spMANGLED</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a5">spNO_MEMORY</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a6">spPANIC</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a7">spFATAL</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a8">spREAL</a>&nbsp;&nbsp;&nbsp;double</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a9">spDEFAULT_PARTITION</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a10">spDIRECT_PARTITION</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a11">spINDIRECT_PARTITION</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a12">spAUTO_PARTITION</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a13">spADD_REAL_ELEMENT</a>(element, real)&nbsp;&nbsp;&nbsp;*(element) += real</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a14">spADD_IMAG_ELEMENT</a>(element, imag)&nbsp;&nbsp;&nbsp;*(element+1) += imag</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a15">spADD_COMPLEX_ELEMENT</a>(element, real, imag)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a16">spADD_REAL_QUAD</a>(template, real)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a17">spADD_IMAG_QUAD</a>(template, imag)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a18">spADD_COMPLEX_QUAD</a>(template, real, imag)</td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td nowrap align=right valign=top>typedef spGenericPtr&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a19">spMatrix</a></td></tr>
<tr><td nowrap align=right valign=top>typedef spREAL&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a20">spElement</a></td></tr>
<tr><td nowrap align=right valign=top>typedef int&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a21">spError</a></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a22">spClear</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN spREAL&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a23">spCondition</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, spREAL, int *)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN <a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a24">spCreate</a> (int, int, <a class="el" href="spMatrix_8h.html#a21">spError</a> *)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a25">spDeleteRowAndCol</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int, int)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a26">spDestroy</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN int&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a27">spElementCount</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a>&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a28">spErrorState</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a29">spErrorMessage</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, FILE *, char *)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a>&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a30">spFactor</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN int&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a31">spFileMatrix</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, char *, char *, int, int, int)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN int&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a32">spFileStats</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, char *, char *)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN int&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a33">spFillinCount</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN <a class="el" href="spMatrix_8h.html#a20">spElement</a> *&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a34">spFindElement</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int, int)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a>&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a35">spGetAdmittance</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int, int, struct <a class="el" href="structspTemplate.html">spTemplate</a> *)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN <a class="el" href="spMatrix_8h.html#a20">spElement</a> *&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a36">spGetElement</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int, int)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN spGenericPtr&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a37">spGetInitInfo</a> (<a class="el" href="spMatrix_8h.html#a20">spElement</a> *)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a>&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a38">spGetOnes</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int, int, int, struct <a class="el" href="structspTemplate.html">spTemplate</a> *)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a>&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a39">spGetQuad</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int, int, int, int, struct <a class="el" href="structspTemplate.html">spTemplate</a> *)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN int&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a40">spGetSize</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int)</td></tr>
<tr><td nowrap align=right valign=top><a name="a41" doxytag="spMatrix.h::spInitialize"></a>
spcEXTERN int&nbsp;</td><td valign=bottom><b>spInitialize</b> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int(*pInit)(<a class="el" href="spMatrix_8h.html#a20">spElement</a> *, spGenericPtr, int, int))</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a42">spInstallInitInfo</a> (<a class="el" href="spMatrix_8h.html#a20">spElement</a> *, spGenericPtr)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN spREAL&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a43">spLargestElement</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a44">spMNA_Preorder</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN spREAL&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a45">spNorm</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a>&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, spREAL[], spREAL, spREAL, int)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a47">spPartition</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a48">spPrint</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int, int, int)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN spREAL&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a49">spPseudoCondition</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN spREAL&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a50">spRoundoff</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, spREAL)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a51">spScale</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, spREAL[], spREAL[])</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a52">spSetComplex</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a53">spSetReal</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a54">spStripFills</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a55">spWhereSingular</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int *, int *)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a56">spDeterminant</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, int *, spREAL *, spREAL *)</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN int&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a57">spFileVector</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, char *, spREAL[])</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a58">spMultiply</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, spREAL[], spREAL[])</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a59">spMultTransposed</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, spREAL[], spREAL[])</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a60">spSolve</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, spREAL[], spREAL[])</td></tr>
<tr><td nowrap align=right valign=top>spcEXTERN void&nbsp;</td><td valign=bottom><a class="el" href="spMatrix_8h.html#a61">spSolveTransposed</a> (<a class="el" href="spMatrix_8h.html#a19">spMatrix</a>, spREAL[], spREAL[])</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
This file contains definitions that are useful to the calling program. In particular, this file contains error keyword definitions, some macro functions that are used to quickly enter data into the matrix and the type definition of a data structure that acts as a template for entering admittances into the matrix. Also included is the type definitions for the various functions available to the user.
<p>
Objects that begin with the <em>spc</em> prefix are considered private and should not be used.
<p>
<dl compact><dt><b>Author: </b></dt><dd>
 Kenneth S. Kundert &lt;<a href="mailto:kundert@users.sourceforge.net">kundert@users.sourceforge.net</a>&gt;</dl><hr><h2>Define Documentation</h2>
<a name="a15" doxytag="spMatrix.h::spADD_COMPLEX_ELEMENT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spADD_COMPLEX_ELEMENT</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">element,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>imag&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>{   *(element) += real;                                 \
    *(element+1) += imag;                               \
}</pre></div>Macro function that adds data to a complex element in the matrix by a pointer.     </td>
  </tr>
</table>
<a name="a18" doxytag="spMatrix.h::spADD_COMPLEX_QUAD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spADD_COMPLEX_QUAD</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">template,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>imag&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>{   *((template).Element1) += real;             \
    *((template).Element2) += real;             \
    *((template).Element3Negated) -= real;      \
    *((template).Element4Negated) -= real;      \
    *((template).Element1+1) += imag;           \
    *((template).Element2+1) += imag;           \
    *((template).Element3Negated+1) -= imag;    \
    *((template).Element4Negated+1) -= imag;    \
}</pre></div>Macro function that adds data to each of the four complex matrix elements specified by the given template.     </td>
  </tr>
</table>
<a name="a14" doxytag="spMatrix.h::spADD_IMAG_ELEMENT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spADD_IMAG_ELEMENT</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">element,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>imag&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;*(element+1) += imag
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Macro function that adds data to a imaginary element in the matrix by a pointer.     </td>
  </tr>
</table>
<a name="a17" doxytag="spMatrix.h::spADD_IMAG_QUAD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spADD_IMAG_QUAD</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">template,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>imag&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>{   *((template).Element1+1) += imag;           \
    *((template).Element2+1) += imag;           \
    *((template).Element3Negated+1) -= imag;    \
    *((template).Element4Negated+1) -= imag;    \
}</pre></div>Macro function that adds data to each of the four imaginary matrix elements specified by the given template.     </td>
  </tr>
</table>
<a name="a13" doxytag="spMatrix.h::spADD_REAL_ELEMENT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spADD_REAL_ELEMENT</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">element,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;*(element) += real
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Macro function that adds data to a real element in the matrix by a pointer.     </td>
  </tr>
</table>
<a name="a16" doxytag="spMatrix.h::spADD_REAL_QUAD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spADD_REAL_QUAD</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">template,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>real&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>{   *((template).Element1) += real;             \
    *((template).Element2) += real;             \
    *((template).Element3Negated) -= real;      \
    *((template).Element4Negated) -= real;      \
}</pre></div>Macro function that adds data to each of the four real matrix elements specified by the given template.     </td>
  </tr>
</table>
<a name="a12" doxytag="spMatrix.h::spAUTO_PARTITION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spAUTO_PARTITION&nbsp;&nbsp;&nbsp;3
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Partition code for <a class="el" href="spMatrix_8h.html#a47">spPartition</a>(). Indicates that <em>Sparse</em> should chose the best partition for each row based on some simple rules. This is generally preferred. <dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spMatrix_8h.html#a47">spPartition</a>() </dl>    </td>
  </tr>
</table>
<a name="a9" doxytag="spMatrix.h::spDEFAULT_PARTITION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spDEFAULT_PARTITION&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Partition code for <a class="el" href="spMatrix_8h.html#a47">spPartition</a>(). Indicates that the default partitioning mode should be used. <dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spMatrix_8h.html#a47">spPartition</a>() </dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="spMatrix.h::spDIRECT_PARTITION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spDIRECT_PARTITION&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Partition code for <a class="el" href="spMatrix_8h.html#a47">spPartition</a>(). Indicates that all rows should be placed in the direct addressing partition. <dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spMatrix_8h.html#a47">spPartition</a>() </dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="spMatrix.h::spFATAL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spFATAL&nbsp;&nbsp;&nbsp;2
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Error code that is not an error flag, but rather the dividing line between fatal errors and warnings.     </td>
  </tr>
</table>
<a name="a11" doxytag="spMatrix.h::spINDIRECT_PARTITION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spINDIRECT_PARTITION&nbsp;&nbsp;&nbsp;2
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Partition code for <a class="el" href="spMatrix_8h.html#a47">spPartition</a>(). Indicates that all rows should be placed in the indirect addressing partition. <dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spMatrix_8h.html#a47">spPartition</a>() </dl>    </td>
  </tr>
</table>
<a name="a4" doxytag="spMatrix.h::spMANGLED"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spMANGLED&nbsp;&nbsp;&nbsp;4
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fatal error code that indicates that, matrix has been mangled, results of requested operation are garbage.     </td>
  </tr>
</table>
<a name="a5" doxytag="spMatrix.h::spNO_MEMORY"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spNO_MEMORY&nbsp;&nbsp;&nbsp;5
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fatal error code that indicates that not enough memory is available.     </td>
  </tr>
</table>
<a name="a0" doxytag="spMatrix.h::spOKAY"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spOKAY&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Error code that indicates that no error has occurred.     </td>
  </tr>
</table>
<a name="a6" doxytag="spMatrix.h::spPANIC"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spPANIC&nbsp;&nbsp;&nbsp;6
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fatal error code that indicates that the routines are not prepared to handle the matrix that has been requested. This may occur when the matrix is specified to be real and the routines are not compiled for real matrices, or when the matrix is specified to be complex and the routines are not compiled to handle complex matrices.     </td>
  </tr>
</table>
<a name="a8" doxytag="spMatrix.h::spREAL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spREAL&nbsp;&nbsp;&nbsp;double
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines the precision of the arithmetic used by <em>Sparse</em> will use. Double precision is suggested as being most appropriate for circuit simulation and for C. However, it is possible to change spREAL to a float for single precision arithmetic. Note that in C, single precision arithmetic is often slower than double precision. Sparse internally refers to spREALs as RealNumbers.     </td>
  </tr>
</table>
<a name="a3" doxytag="spMatrix.h::spSINGULAR"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spSINGULAR&nbsp;&nbsp;&nbsp;3
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fatal error code that indicates that, matrix is singular, so no unique solution exists.     </td>
  </tr>
</table>
<a name="a1" doxytag="spMatrix.h::spSMALL_PIVOT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spSMALL_PIVOT&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Non-fatal error code that indicates that, when reordering the matrix, no element was found that satisfies the absolute threshold criteria. The largest element in the matrix was chosen as pivot.     </td>
  </tr>
</table>
<a name="a2" doxytag="spMatrix.h::spZERO_DIAG"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spZERO_DIAG&nbsp;&nbsp;&nbsp;2
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fatal error code that indicates that, a zero was encountered on the diagonal the matrix. This does not necessarily imply that the matrix is singular. When this error occurs, the matrix should be reconstructed and factored using <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>().     </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a name="a20" doxytag="spMatrix.h::spElement"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef spREAL spElement
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Declares the type of the a pointer to a matrix element.     </td>
  </tr>
</table>
<a name="a21" doxytag="spMatrix.h::spError"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef int spError
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Declares the type of the Sparse error codes.     </td>
  </tr>
</table>
<a name="a19" doxytag="spMatrix.h::spMatrix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef spGenericPtr spMatrix
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Declares the type of the a pointer to a matrix.     </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a22" doxytag="spMatrix.h::spClear"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spClear </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets every element of the matrix to zero and clears the error flag.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix that is to be cleared. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a23" doxytag="spMatrix.h::spCondition"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN spREAL spCondition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>NormOfMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pError</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes an estimate of the condition number using a variation on the LINPACK condition number estimation algorithm. This quantity is an indicator of ill-conditioning in the matrix. To avoid problems with overflow, the reciprocal of the condition number is returned. If this number is small, and if the matrix is scaled such that uncertainties in the RHS and the matrix entries are equilibrated, then the matrix is ill-conditioned. If the this number is near one, the matrix is well conditioned. This routine must only be used after a matrix has been factored by <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>() or <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() and before it is cleared by <a class="el" href="spMatrix_8h.html#a22">spClear</a>() or <a class="el" href="spMatrix_8h.html">spInitialize</a>().
<p>
Unlike the LINPACK condition number estimator, this routines returns the L infinity condition number. This is an artifact of Sparse placing ones on the diagonal of the upper triangular matrix rather than the lower. This difference should be of no importance.
<p>
<b>References</b>:
<p>
A.K. Cline, C.B. Moler, G.W. Stewart, J.H. Wilkinson. An estimate for the condition number of a matrix. SIAM Journal on Numerical Analysis. Vol. 16, No. 2, pages 368-375, April 1979.
<p>
J.J. Dongarra, C.B. Moler, J.R. Bunch, G.W. Stewart. LINPACK User's Guide. SIAM, 1979.
<p>
Roger G. Grimes, John G. Lewis. Condition number estimation for sparse matrices. SIAM Journal on Scientific and Statistical Computing. Vol. 2, No. 4, pages 384-388, December 1981.
<p>
Dianne Prost O'Leary. Estimating matrix condition numbers. SIAM Journal on Scientific and Statistical Computing. Vol. 1, No. 2, pages 205-209, June 1980.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 The reciprocal of the condition number. If the matrix was singular, zero is returned.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
<tr><td valign=top><em>NormOfMatrix</em>&nbsp;</td><td>
The L-infinity norm of the unfactored matrix as computed by <a class="el" href="spMatrix_8h.html#a45">spNorm</a>(). </td></tr>
<tr><td valign=top><em>pError</em>&nbsp;</td><td>
Used to return error code. Possible errors include <em>spSINGULAR</em> or <em>spNO_MEMORY</em>. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a24" doxytag="spMatrix.h::spCreate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN <a class="el" href="spMatrix_8h.html#a19">spMatrix</a> spCreate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Complex</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="spMatrix_8h.html#a21">spError</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pError</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocates and initializes the data structures associated with a matrix.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 A pointer to the matrix is returned cast into <em><a class="el" href="spMatrix_8h.html#a19">spMatrix</a></em> (typically a pointer to a void). This pointer is then passed and used by the other matrix routines to refer to a particular matrix. If an error occurs, the <em>NULL</em> pointer is returned.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>Size</em>&nbsp;</td><td>
Size of matrix or estimate of size of matrix if matrix is <em>EXPANDABLE</em>. </td></tr>
<tr><td valign=top><em>Complex</em>&nbsp;</td><td>
Type of matrix. If <em>Complex</em> is 0 then the matrix is real, otherwise the matrix will be complex. Note that if the routines are not set up to handle the type of matrix requested, then an <em>spPANIC</em> error will occur. Further note that if a matrix will be both real and complex, it must be specified here as being complex. </td></tr>
<tr><td valign=top><em>pError</em>&nbsp;</td><td>
Returns error flag, needed because function <em><a class="el" href="spMatrix_8h.html#a28">spErrorState</a>()</em> will not work correctly if <em><a class="el" href="spMatrix_8h.html#a24">spCreate</a>()</em> returns <em>NULL</em>. Possible errors include <em>spNO_MEMORY</em> and <em>spPANIC</em>. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a25" doxytag="spMatrix.h::spDeleteRowAndCol"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spDeleteRowAndCol </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Row</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Col</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a row and a column from a matrix.
<p>
Sparse will abort if an attempt is made to delete a row or column that doesn't exist.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix in which the row and column are to be deleted. </td></tr>
<tr><td valign=top><em>Row</em>&nbsp;</td><td>
Row to be deleted. </td></tr>
<tr><td valign=top><em>Col</em>&nbsp;</td><td>
Column to be deleted. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a26" doxytag="spMatrix.h::spDestroy"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spDestroy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroys a matrix and frees all memory associated with it.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix frame which is to be destroyed. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a56" doxytag="spMatrix.h::spDeterminant"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spDeterminant </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pExponent</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pDeterminant</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>piDeterminant</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine in capable of calculating the determinant of the matrix once the LU factorization has been performed. Hence, only use this routine after <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() and before <a class="el" href="spMatrix_8h.html#a22">spClear</a>(). The determinant equals the product of all the diagonal elements of the lower triangular matrix L, except that this product may need negating. Whether the product or the negative product equals the determinant is determined by the number of row and column interchanges performed. Note that the determinants of matrices can be very large or very small. On large matrices, the determinant can be far larger or smaller than can be represented by a floating point number. For this reason the determinant is scaled to a reasonable value and the logarithm of the scale factor is returned.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
A pointer to the matrix for which the determinant is desired. </td></tr>
<tr><td valign=top><em>pExponent</em>&nbsp;</td><td>
The logarithm base 10 of the scale factor for the determinant. To find the actual determinant, Exponent should be added to the exponent of Determinant. </td></tr>
<tr><td valign=top><em>pDeterminant</em>&nbsp;</td><td>
The real portion of the determinant. This number is scaled to be greater than or equal to 1.0 and less than 10.0. </td></tr>
<tr><td valign=top><em>piDeterminant</em>&nbsp;</td><td>
The imaginary portion of the determinant. When the matrix is real this pointer need not be supplied, nothing will be returned. This number is scaled to be greater than or equal to 1.0 and less than 10.0. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a27" doxytag="spMatrix.h::spElementCount"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN int spElementCount </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the total number of elements (including fill-ins) that currently exists in a matrix.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a29" doxytag="spMatrix.h::spErrorMessage"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spErrorMessage </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Stream</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Originator</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine prints a short message describing the error error state of sparse. No message is produced if there is no error. The error state is cleared.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Matrix for which the error message is to be printed. </td></tr>
<tr><td valign=top><em>Stream</em>&nbsp;</td><td>
Stream to which the error message is to be printed. </td></tr>
<tr><td valign=top><em>Originator</em>&nbsp;</td><td>
Name of originator of error message. If NULL, `sparse' is used. If zero-length string, no originator is printed. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a28" doxytag="spMatrix.h::spErrorState"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a> spErrorState </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the error status of the given matrix.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 The error status of the given matrix.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
The pointer to the matrix for which the error status is desired. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a30" doxytag="spMatrix.h::spFactor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a> spFactor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine is the companion routine to <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>(). Unlike <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>(), <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() cannot change the ordering. It is also faster than <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>(). The standard way of using these two routines is to first use <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>() for the initial factorization. For subsequent factorizations, <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() is used if there is some assurance that little growth will occur (say for example, that the matrix is diagonally dominant). If <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() is called for the initial factorization of the matrix, then <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>() is automatically called with the default threshold. This routine uses "row at a time" <em>LU</em> factorization. Pivots are associated with the lower triangular matrix and the diagonals of the upper triangular matrix are ones.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 The error code is returned. Possible errors are <em>spNO_MEMORY</em>, <em>spSINGULAR</em>, <em>spZERO_DIAG</em> and <em>spSMALL_PIVOT</em>. Error is cleared upon entering this function.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>() </dl>    </td>
  </tr>
</table>
<a name="a31" doxytag="spMatrix.h::spFileMatrix"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN int spFileMatrix </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>File</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Label</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Reordered</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Header</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes matrix to file in format suitable to be read back in by the matrix test program.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 One is returned if routine was successful, otherwise zero is returned. The calling function can query <em>errno</em> (the system global error variable) as to the reason why this routine failed.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
<tr><td valign=top><em>File</em>&nbsp;</td><td>
Name of file into which matrix is to be written. </td></tr>
<tr><td valign=top><em>Label</em>&nbsp;</td><td>
String that is transferred to file and is used as a label. </td></tr>
<tr><td valign=top><em>Reordered</em>&nbsp;</td><td>
Specifies whether matrix should be output in reordered form, or in original order. </td></tr>
<tr><td valign=top><em>Data</em>&nbsp;</td><td>
Indicates that the element values should be output along with the indices for each element. This parameter must be true if matrix is to be read by the sparse test program. </td></tr>
<tr><td valign=top><em>Header</em>&nbsp;</td><td>
Indicates that header is desired. This parameter must be true if matrix is to be read by the sparse test program. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a32" doxytag="spMatrix.h::spFileStats"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN int spFileStats </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>File</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Label</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes useful information concerning the matrix to a file. Should be executed after the matrix is factored.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 One is returned if routine was successful, otherwise zero is returned. The calling function can query <em>errno</em> (the system global error variable) as to the reason why this routine failed.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
<tr><td valign=top><em>File</em>&nbsp;</td><td>
Name of file into which matrix is to be written. </td></tr>
<tr><td valign=top><em>Label</em>&nbsp;</td><td>
String that is transferred to file and is used as a label. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a57" doxytag="spMatrix.h::spFileVector"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN int spFileVector </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>File</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RHS</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes vector to file in format suitable to be read back in by the matrix test program. This routine should be executed after the function spFileMatrix.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 One is returned if routine was successful, otherwise zero is returned. The calling function can query <em>errno</em> (the system global error variable) as to the reason why this routine failed.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
<tr><td valign=top><em>File</em>&nbsp;</td><td>
Name of file into which matrix is to be written. </td></tr>
<tr><td valign=top><em>RHS</em>&nbsp;</td><td>
Right-hand side vector. This is only the real portion if <em>spSEPARATED_COMPLEX_VECTORS</em> is true. </td></tr>
<tr><td valign=top><em>iRHS</em>&nbsp;</td><td>
Right-hand side vector, imaginary portion. Not necessary if matrix is real or if <em>spSEPARATED_COMPLEX_VECTORS</em> is set false. <em>iRHS</em> is a macro that replaces itself with `, iRHS' if the options <em>spCOMPLEX</em> and <em>spSEPARATED_COMPLEX_VECTORS</em> are set, otherwise it disappears without a trace. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a33" doxytag="spMatrix.h::spFillinCount"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN int spFillinCount </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the number of fill-ins that currently exists in a matrix.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a34" doxytag="spMatrix.h::spFindElement"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN <a class="el" href="spMatrix_8h.html#a20">spElement</a>* spFindElement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Row</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Col</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine is used to find an element given its indices. It will not create it if it does not exist.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 A pointer to the desired element, or <em>NULL</em> if it does not exist.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
<tr><td valign=top><em>Row</em>&nbsp;</td><td>
Row index for element. </td></tr>
<tr><td valign=top><em>Col</em>&nbsp;</td><td>
Column index for element.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spMatrix_8h.html#a36">spGetElement</a>() </dl>    </td>
  </tr>
</table>
<a name="a35" doxytag="spMatrix.h::spGetAdmittance"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a> spGetAdmittance </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Matrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Node1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Node2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structspTemplate.html">spTemplate</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Template</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs same function as <a class="el" href="spMatrix_8h.html#a36">spGetElement</a>() except rather than one element, all four matrix elements for a floating two terminal admittance component are added. This routine also works if component is grounded. Positive elements are placed at [Node1,Node2] and [Node2,Node1]. This routine is only to be used after <a class="el" href="spMatrix_8h.html#a24">spCreate</a>() and before <a class="el" href="spMatrix_8h.html#a44">spMNA_Preorder</a>(), <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() or <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>().
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 Error code. Possible errors include <em>spNO_MEMORY</em>. Error is not cleared in this routine.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>Matrix</em>&nbsp;</td><td>
Pointer to the matrix that component is to be entered in. </td></tr>
<tr><td valign=top><em>Node1</em>&nbsp;</td><td>
Row and column indices for elements. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Node zero is the ground node. In no case may <em>Node1</em> be less than zero. </td></tr>
<tr><td valign=top><em>Node2</em>&nbsp;</td><td>
Row and column indices for elements. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Node zero is the ground node. In no case may <em>Node2</em> be less than zero. </td></tr>
<tr><td valign=top><em>Template</em>&nbsp;</td><td>
Collection of pointers to four elements that are later used to directly address elements. User must supply the template, this routine will fill it. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a36" doxytag="spMatrix.h::spGetElement"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN <a class="el" href="spMatrix_8h.html#a20">spElement</a>* spGetElement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Row</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Col</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Finds element [Row,Col] and returns a pointer to it. If element is not found then it is created and spliced into matrix. This routine is only to be used after <a class="el" href="spMatrix_8h.html#a24">spCreate</a>() and before <a class="el" href="spMatrix_8h.html#a44">spMNA_Preorder</a>(), <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() or <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>(). Returns a pointer to the real portion of an <em><a class="el" href="spMatrix_8h.html#a20">spElement</a></em>. This pointer is later used by <em>spADD_xxx_ELEMENT</em> to directly access element.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 Returns a pointer to the element. This pointer is then used to directly access the element during successive builds.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix that the element is to be added to. </td></tr>
<tr><td valign=top><em>Row</em>&nbsp;</td><td>
Row index for element. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Elements placed in row zero are discarded. In no case may <em>Row</em> be less than zero. </td></tr>
<tr><td valign=top><em>Col</em>&nbsp;</td><td>
Column index for element. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Elements placed in column zero are discarded. In no case may <em>Col</em> be less than zero.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spMatrix_8h.html#a34">spFindElement</a>() </dl>    </td>
  </tr>
</table>
<a name="a37" doxytag="spMatrix.h::spGetInitInfo"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN spGenericPtr spGetInitInfo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a20">spElement</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>pElement</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns a pointer to a data structure that is used to contain initialization information to a matrix element.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 The pointer to the initialiation information data structure that is associated with a particular matrix element.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>pElement</em>&nbsp;</td><td>
Pointer to the matrix element.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spMatrix_8h.html">spInitialize</a>() </dl>    </td>
  </tr>
</table>
<a name="a38" doxytag="spMatrix.h::spGetOnes"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a> spGetOnes </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Matrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Pos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Neg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Eqn</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structspTemplate.html">spTemplate</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Template</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Addition of four structural ones to matrix by index. Performs similar function to <a class="el" href="spMatrix_8h.html#a39">spGetQuad</a>() except this routine is meant for components that do not have an admittance representation.
<p>
The following stamp is used: <div class="fragment"><pre>         Pos  Neg  Eqn
  Pos  [  .    .    1  ]
  Neg  [  .    .   -1  ]
  Eqn  [  1   -1    .  ]
</pre></div>
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 Error code. Possible errors include <em>spNO_MEMORY</em>. Error is not cleared in this routine.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>Matrix</em>&nbsp;</td><td>
Pointer to the matrix that component is to be entered in. </td></tr>
<tr><td valign=top><em>Pos</em>&nbsp;</td><td>
See stamp above. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Zero is the ground row. In no case may <em>Pos</em> be less than zero. </td></tr>
<tr><td valign=top><em>Neg</em>&nbsp;</td><td>
See stamp above. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Zero is the ground row. In no case may <em>Neg</em> be less than zero. </td></tr>
<tr><td valign=top><em>Eqn</em>&nbsp;</td><td>
See stamp above. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Zero is the ground row. In no case may <em>Eqn</em> be less than zero. </td></tr>
<tr><td valign=top><em>Template</em>&nbsp;</td><td>
Collection of pointers to four elements that are later used to directly address elements. User must supply the template, this routine will fill it. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a39" doxytag="spMatrix.h::spGetQuad"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a> spGetQuad </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Matrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Row1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Row2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Col1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Col2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct <a class="el" href="structspTemplate.html">spTemplate</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Template</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Similar to <a class="el" href="spMatrix_8h.html#a35">spGetAdmittance</a>(), except that <a class="el" href="spMatrix_8h.html#a35">spGetAdmittance</a>() only handles 2-terminal components, whereas <a class="el" href="spMatrix_8h.html#a39">spGetQuad</a>() handles simple 4-terminals as well. These 4-terminals are simply generalized 2-terminals with the option of having the sense terminals different from the source and sink terminals. <a class="el" href="spMatrix_8h.html#a39">spGetQuad</a>() adds four elements to the matrix. Positive elements occur at [Row1,Col1] [Row2,Col2] while negative elements occur at [Row1,Col2] and [Row2,Col1]. The routine works fine if any of the rows and columns are zero. This routine is only to be used after <a class="el" href="spMatrix_8h.html#a24">spCreate</a>() and before <a class="el" href="spMatrix_8h.html#a44">spMNA_Preorder</a>(), <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() or <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>() unless <em>TRANSLATE</em> is set true.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 Error code. Possible errors include <em>spNO_MEMORY</em>. Error is not cleared in this routine.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>Matrix</em>&nbsp;</td><td>
Pointer to the matrix that component is to be entered in. </td></tr>
<tr><td valign=top><em>Row1</em>&nbsp;</td><td>
First row index for elements. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Zero is the ground row. In no case may Row1 be less than zero. </td></tr>
<tr><td valign=top><em>Row2</em>&nbsp;</td><td>
Second row index for elements. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Zero is the ground row. In no case may Row2 be less than zero. </td></tr>
<tr><td valign=top><em>Col1</em>&nbsp;</td><td>
First column index for elements. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Zero is the ground column. In no case may Col1 be less than zero. </td></tr>
<tr><td valign=top><em>Col2</em>&nbsp;</td><td>
Second column index for elements. Must be in the range of [0..Size] unless the options <em>EXPANDABLE</em> or <em>TRANSLATE</em> are used. Zero is the ground column. In no case may Col2 be less than zero. </td></tr>
<tr><td valign=top><em>Template</em>&nbsp;</td><td>
Collection of pointers to four elements that are later used to directly address elements. User must supply the template, this routine will fill it. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a40" doxytag="spMatrix.h::spGetSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN int spGetSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>External</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the size of the matrix. Either the internal or external size of the matrix is returned.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
<tr><td valign=top><em>External</em>&nbsp;</td><td>
If <em>External</em> is set true, the external size , i.e., the value of the largest external row or column number encountered is returned. Otherwise the true size of the matrix is returned. These two sizes may differ if the <em>TRANSLATE</em> option is set true. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a42" doxytag="spMatrix.h::spInstallInitInfo"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spInstallInitInfo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a20">spElement</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pElement</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spGenericPtr&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pInitInfo</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function installs a pointer to a data structure that is used to contain initialization information to a matrix element. It is is then used by <a class="el" href="spMatrix_8h.html">spInitialize</a>() to initialize the matrix.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>pElement</em>&nbsp;</td><td>
Pointer to matrix element. </td></tr>
<tr><td valign=top><em>pInitInfo</em>&nbsp;</td><td>
Pointer to the data structure that will contain initialiation information. </td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spMatrix_8h.html">spInitialize</a>() </dl>    </td>
  </tr>
</table>
<a name="a43" doxytag="spMatrix.h::spLargestElement"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN spREAL spLargestElement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine, along with <a class="el" href="spMatrix_8h.html#a50">spRoundoff</a>(), are used to gauge the stability of a factorization. If the factorization is determined to be too unstable, then the matrix should be reordered. The routines compute quantities that are needed in the computation of a bound on the error attributed to any one element in the matrix during the factorization. In other words, there is a matrix <img align="top" src="form_0.png">
 of error terms such that <img align="top" src="form_1.png">
. This routine finds a bound on <img align="top" src="form_2.png">
. Erisman &amp; Reid [1] showed that <img align="top" src="form_3.png">
, where <img align="top" src="form_4.png">
 is the machine rounding unit, <img align="top" src="form_5.png">
 where the max is taken over every row <img align="top" src="form_6.png">
, column <img align="top" src="form_7.png">
, and step <img align="top" src="form_8.png">
, and <img align="top" src="form_9.png">
 is the number of multiplications required in the computation of <img align="top" src="form_10.png">
 if <img align="top" src="form_11.png">
 or <img align="top" src="form_12.png">
 otherwise. Barlow [2] showed that <img align="top" src="form_13.png">
 where <img align="top" src="form_14.png">
.
<p>
<a class="el" href="spMatrix_8h.html#a43">spLargestElement</a>() finds the magnitude on the largest element in the matrix. If the matrix has not yet been factored, the largest element is found by direct search. If the matrix is factored, a bound on the largest element in any of the reduced submatrices is computed using Barlow with <img align="top" src="form_15.png">
 and <img align="top" src="form_16.png">
. The ratio of these two numbers is the growth, which can be used to determine if the pivoting order is adequate. A large growth implies that considerable error has been made in the factorization and that it is probably a good idea to reorder the matrix. If a large growth in encountered after using <a class="el" href="spMatrix_8h.html#a30">spFactor</a>(), reconstruct the matrix and refactor using <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>(). If a large growth is encountered after using <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>(), refactor using <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>() with the pivot threshold increased, say to 0.1.
<p>
Using only the size of the matrix as an upper bound on <img align="top" src="form_9.png">
 and Barlow's bound, the user can estimate the size of the matrix error terms <img align="top" src="form_17.png">
 using the bound of Erisman and Reid. <a class="el" href="spMatrix_8h.html#a50">spRoundoff</a>()  computes a tighter bound (with more work) based on work by Gear [3], <img align="top" src="form_18.png">
 where <img align="top" src="form_19.png">
 is the threshold and <img align="top" src="form_20.png">
 is the maximum number of off-diagonal elements in any row of <img align="top" src="form_21.png">
. The expensive part of computing this bound is determining the maximum number of off-diagonals in <img align="top" src="form_21.png">
, which changes only when the order of the matrix changes. This number is computed and saved, and only recomputed if the matrix is reordered.
<p>
[1] A. M. Erisman, J. K. Reid. Monitoring the stability of the triangular factorization of a sparse matrix. Numerische Mathematik. Vol. 22, No. 3, 1974, pp 183-186.
<p>
[2] J. L. Barlow. A note on monitoring the stability of triangular decomposition of sparse matrices. "SIAM Journal of Scientific and Statistical Computing." Vol. 7, No. 1, January 1986, pp 166-168.
<p>
[3] I. S. Duff, A. M. Erisman, J. K. Reid. "Direct Methods for Sparse Matrices." Oxford 1986. pp 99.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 If matrix is not factored, returns the magnitude of the largest element in the matrix. If the matrix is factored, a bound on the magnitude of the largest element in any of the reduced submatrices is returned.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a44" doxytag="spMatrix.h::spMNA_Preorder"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spMNA_Preorder </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine massages modified node admittance matrices to remove zeros from the diagonal. It takes advantage of the fact that the row and column associated with a zero diagonal usually have structural ones placed symmetricly. This routine should be used only on modified node admittance matrices and should be executed after the matrix has been built but before the factorization begins. It should be executed for the initial factorization only and should be executed before the rows have been linked. Thus it should be run before using <a class="el" href="spMatrix_8h.html#a51">spScale</a>(), <a class="el" href="spMatrix_8h.html#a58">spMultiply</a>(), <a class="el" href="spMatrix_8h.html#a25">spDeleteRowAndCol</a>(), or <a class="el" href="spMatrix_8h.html#a45">spNorm</a>().
<p>
This routine exploits the fact that the structural ones are placed in the matrix in symmetric twins. For example, the stamps for grounded and a floating voltage sources are <div class="fragment"><pre>  grounded:              floating:
  [  x   x   1 ]         [  x   x   1 ]
  [  x   x     ]         [  x   x  -1 ]
  [  1         ]         [  1  -1     ]
</pre></div> Notice for the grounded source, there is one set of twins, and for the floating, there are two sets. We remove the zero from the diagonal by swapping the rows associated with a set of twins. For example: <div class="fragment"><pre>  grounded:              floating 1:            floating 2:
  [  1         ]         [  1  -1     ]         [  x   x   1 ]
  [  x   x     ]         [  x   x  -1 ]         [  1  -1     ]
  [  x   x   1 ]         [  x   x   1 ]         [  x   x  -1 ]
</pre></div>
<p>
It is important to deal with any zero diagonals that only have one set of twins before dealing with those that have more than one because swapping row destroys the symmetry of any twins in the rows being swapped, which may limit future moves. Consider <div class="fragment"><pre>  [  x   x   1     ]
  [  x   x  -1   1 ]
  [  1  -1         ]
  [      1         ]
</pre></div> There is one set of twins for diagonal 4 and two for diagonal 3. Dealing with diagonal 4 first requires swapping rows 2 and 4. <div class="fragment"><pre>  [  x   x   1     ]
  [      1         ]
  [  1  -1         ]
  [  x   x  -1   1 ]
</pre></div> We can now deal with diagonal 3 by swapping rows 1 and 3. <div class="fragment"><pre>  [  1  -1         ]
  [      1         ]
  [  x   x   1     ]
  [  x   x  -1   1 ]
</pre></div> And we are done, there are no zeros left on the diagonal. However, if we originally dealt with diagonal 3 first, we could swap rows 2 and 3 <div class="fragment"><pre>  [  x   x   1     ]
  [  1  -1         ]
  [  x   x  -1   1 ]
  [      1         ]
</pre></div> Diagonal 4 no longer has a symmetric twin and we cannot continue.
<p>
So we always take care of lone twins first. When none remain, we choose arbitrarily a set of twins for a diagonal with more than one set and swap the rows corresponding to that twin. We then deal with any lone twins that were created and repeat the procedure until no zero diagonals with symmetric twins remain.
<p>
In this particular implementation, columns are swapped rather than rows. The algorithm used in this function was developed by Ken Kundert and Tom Quarles.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix to be preordered. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a58" doxytag="spMatrix.h::spMultiply"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spMultiply </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RHS</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Solution</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Multiplies matrix by solution vector to find source vector. Assumes matrix has not been factored. This routine can be used as a test to see if solutions are correct. It should not be used before <a class="el" href="spMatrix_8h.html#a44">spMNA_Preorder</a>().<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
<tr><td valign=top><em>RHS</em>&nbsp;</td><td>
RHS is the right hand side. This is what is being solved for. </td></tr>
<tr><td valign=top><em>Solution</em>&nbsp;</td><td>
Solution is the vector being multiplied by the matrix. </td></tr>
<tr><td valign=top><em>iRHS</em>&nbsp;</td><td>
iRHS is the imaginary portion of the right hand side. This is what is being solved for. This is only necessary if the matrix is complex and <em>spSEPARATED_COMPLEX_VECTORS</em> is true. </td></tr>
<tr><td valign=top><em>iSolution</em>&nbsp;</td><td>
iSolution is the imaginary portion of the vector being multiplied by the matrix. This is only necessary if the matrix is complex and <em>spSEPARATED_COMPLEX_VECTORS</em> is true. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a59" doxytag="spMatrix.h::spMultTransposed"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spMultTransposed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RHS</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Solution</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Multiplies transposed matrix by solution vector to find source vector. Assumes matrix has not been factored. This routine can be used as a test to see if solutions are correct. It should not be used before <a class="el" href="spMatrix_8h.html#a44">spMNA_Preorder</a>().<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
<tr><td valign=top><em>RHS</em>&nbsp;</td><td>
RHS is the right hand side. This is what is being solved for. </td></tr>
<tr><td valign=top><em>Solution</em>&nbsp;</td><td>
Solution is the vector being multiplied by the matrix. </td></tr>
<tr><td valign=top><em>iRHS</em>&nbsp;</td><td>
iRHS is the imaginary portion of the right hand side. This is what is being solved for. This is only necessary if the matrix is complex and <em>spSEPARATED_COMPLEX_VECTORS</em> is true. </td></tr>
<tr><td valign=top><em>iSolution</em>&nbsp;</td><td>
iSolution is the imaginary portion of the vector being multiplied by the matrix. This is only necessary if the matrix is complex and <em>spSEPARATED_COMPLEX_VECTORS</em> is true. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a45" doxytag="spMatrix.h::spNorm"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN spREAL spNorm </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the L-infinity norm of an unfactored matrix. It is a fatal error to pass this routine a factored matrix.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 The largest absolute row sum of matrix.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a46" doxytag="spMatrix.h::spOrderAndFactor"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN <a class="el" href="spMatrix_8h.html#a21">spError</a> spOrderAndFactor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RHS</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RelThreshold</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>AbsThreshold</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>DiagPivoting</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine chooses a pivot order for the matrix and factors it into <em>LU</em> form. It handles both the initial factorization and subsequent factorizations when a reordering is desired. This is handled in a manner that is transparent to the user. The routine uses a variation of Gauss's method where the pivots are associated with <em>L</em> and the diagonal terms of <em>U</em> are one.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 The error code is returned. Possible errors are <em>spNO_MEMORY</em>,  <em>spSINGULAR</em> and <em>spSMALL_PIVOT</em>. Error is cleared upon entering this function.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
<tr><td valign=top><em>RHS</em>&nbsp;</td><td>
Representative right-hand side vector that is used to determine pivoting order when the right hand side vector is sparse. If RHS is a NULL pointer then the RHS vector is assumed to be full and it is not used when determining the pivoting order. </td></tr>
<tr><td valign=top><em>RelThreshold</em>&nbsp;</td><td>
This number determines what the pivot relative threshold will be. It should be between zero and one. If it is one then the pivoting method becomes complete pivoting, which is very slow and tends to fill up the matrix. If it is set close to zero the pivoting method becomes strict Markowitz with no threshold. The pivot threshold is used to eliminate pivot candidates that would cause excessive element growth if they were used. Element growth is the cause of roundoff error. Element growth occurs even in well-conditioned matrices. Setting the <em>RelThreshold</em> large will reduce element growth and roundoff error, but setting it too large will cause execution time to be excessive and will result in a large number of fill-ins. If this occurs, accuracy can actually be degraded because of the large number of operations required on the matrix due to the large number of fill-ins. A good value seems to be 0.001. The default is chosen by giving a value larger than one or less than or equal to zero. This value should be increased and the matrix resolved if growth is found to be excessive. Changing the pivot threshold does not improve performance on matrices where growth is low, as is often the case with ill-conditioned matrices. Once a valid threshold is given, it becomes the new default. The default value of <em>RelThreshold</em> was choosen for use with nearly diagonally dominant matrices such as node- and modified-node admittance matrices. For these matrices it is usually best to use diagonal pivoting. For matrices without a strong diagonal, it is usually best to use a larger threshold, such as 0.01 or 0.1. </td></tr>
<tr><td valign=top><em>AbsThreshold</em>&nbsp;</td><td>
The absolute magnitude an element must have to be considered as a pivot candidate, except as a last resort. This number should be set significantly smaller than the smallest diagonal element that is is expected to be placed in the matrix. If there is no reasonable prediction for the lower bound on these elements, then <em>AbsThreshold</em> should be set to zero. <em>AbsThreshold</em> is used to reduce the possibility of choosing as a pivot an element that has suffered heavy cancellation and as a result mainly consists of roundoff error. Once a valid threshold is given, it becomes the new default. </td></tr>
<tr><td valign=top><em>DiagPivoting</em>&nbsp;</td><td>
A flag indicating that pivot selection should be confined to the diagonal if possible. If <em>DiagPivoting</em> is nonzero and if <em>DIAGONAL_PIVOTING</em> is enabled pivots will be chosen only from the diagonal unless there are no diagonal elements that satisfy the threshold criteria. Otherwise, the entire reduced submatrix is searched when looking for a pivot. The diagonal pivoting in Sparse is efficient and well refined, while the off-diagonal pivoting is not. For symmetric and near symmetric matrices, it is best to use diagonal pivoting because it results in the best performance when reordering the matrix and when factoring the matrix without ordering. If there is a considerable amount of nonsymmetry in the matrix, then off-diagonal pivoting may result in a better equation ordering simply because there are more pivot candidates to choose from. A better ordering results in faster subsequent factorizations. However, the initial pivot selection process takes considerably longer for off-diagonal pivoting.</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spMatrix_8h.html#a30">spFactor</a>() </dl>    </td>
  </tr>
</table>
<a name="a47" doxytag="spMatrix.h::spPartition"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spPartition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Mode</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine determines the cost to factor each row using both direct and indirect addressing and decides, on a row-by-row basis, which addressing mode is fastest. This information is used in <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() to speed the factorization.
<p>
When factoring a previously ordered matrix using <a class="el" href="spMatrix_8h.html#a30">spFactor</a>(), Sparse operates on a row-at-a-time basis. For speed, on each step, the row being updated is copied into a full vector and the operations are performed on that vector. This can be done one of two ways, either using direct addressing or indirect addressing. Direct addressing is fastest when the matrix is relatively dense and indirect addressing is best when the matrix is quite sparse. The user selects the type of partition used with <em>Mode</em>. If <em>Mode</em> is set to <em>spDIRECT_PARTITION</em>, then the all rows are placed in the direct addressing partition. Similarly, if <em>Mode</em> is set to <em>spINDIRECT_PARTITION</em>, then the all rows are placed in the indirect addressing partition. By setting <em>Mode</em> to <em>spAUTO_PARTITION</em>, the user allows Sparse to select the partition for each row individually. <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() generally runs faster if Sparse is allowed to choose its own partitioning, however choosing a partition is expensive. The time required to choose a partition is of the same order of the cost to factor the matrix. If you plan to factor a large number of matrices with the same structure, it is best to let Sparse choose the partition. Otherwise, you should choose the partition based on the predicted density of the matrix.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
<tr><td valign=top><em>Mode</em>&nbsp;</td><td>
Mode must be one of three special codes: <em>spDIRECT_PARTITION</em>, <em>spINDIRECT_PARTITION</em>, or <em>spAUTO_PARTITION</em>. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a48" doxytag="spMatrix.h::spPrint"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spPrint </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>PrintReordered</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Header</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Formats and send the matrix to standard output. Some elementary statistics are also output. The matrix is output in a format that is readable by people.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
<tr><td valign=top><em>PrintReordered</em>&nbsp;</td><td>
Indicates whether the matrix should be printed out in its original form, as input by the user, or whether it should be printed in its reordered form, as used by the matrix routines. A zero indicates that the matrix should be printed as inputed, a one indicates that it should be printed reordered. </td></tr>
<tr><td valign=top><em>Data</em>&nbsp;</td><td>
Boolean flag that when false indicates that output should be compressed such that only the existence of an element should be indicated rather than giving the actual value. Thus 11 times as many can be printed on a row. A zero signifies that the matrix should be printed compressed. A one indicates that the matrix should be printed in all its glory. </td></tr>
<tr><td valign=top><em>Header</em>&nbsp;</td><td>
Flag indicating that extra information should be given, such as row and column numbers. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a49" doxytag="spMatrix.h::spPseudoCondition"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN spREAL spPseudoCondition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the magnitude of the ratio of the largest to the smallest pivots. This quantity is an indicator of ill-conditioning in the matrix. If this ratio is large, and if the matrix is scaled such that uncertainties in the RHS and the matrix entries are equilibrated, then the matrix is ill-conditioned. However, a small ratio does not necessarily imply that the matrix is well-conditioned. This routine must only be used after a matrix has been factored by <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>() or <a class="el" href="spMatrix_8h.html#a30">spFactor</a>() and before it is cleared by <a class="el" href="spMatrix_8h.html#a22">spClear</a>() or <a class="el" href="spMatrix_8h.html">spInitialize</a>(). The pseudocondition is faster to compute than the condition number calculated by <a class="el" href="spMatrix_8h.html#a23">spCondition</a>(), but is not as informative.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 The magnitude of the ratio of the largest to smallest pivot used during previous factorization. If the matrix was singular, zero is returned.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a50" doxytag="spMatrix.h::spRoundoff"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN spREAL spRoundoff </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Rho</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine, along with <a class="el" href="spMatrix_8h.html#a43">spLargestElement</a>(), are used to gauge the stability of a factorization. See description of <a class="el" href="spMatrix_8h.html#a43">spLargestElement</a>() for more information.
<p>
<dl compact><dt><b>Returns :</b></dt><dd>
 Returns a bound on the magnitude of the largest element in <img align="top" src="form_22.png">
.</dl><dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix. </td></tr>
<tr><td valign=top><em>Rho</em>&nbsp;</td><td>
The bound on the magnitude of the largest element in any of the reduced submatrices. This is the number computed by the function <a class="el" href="spMatrix_8h.html#a43">spLargestElement</a>() when given a factored matrix. If this number is negative, the bound will be computed automatically. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a51" doxytag="spMatrix.h::spScale"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spScale </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RHS_ScaleFactors</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>SolutionScaleFactors</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function scales the matrix to enhance the possibility of finding a good pivoting order. Note that scaling enhances accuracy of the solution only if it affects the pivoting order, so it makes no sense to scale the matrix before <a class="el" href="spMatrix_8h.html#a30">spFactor</a>(). If scaling is desired it should be done before <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>(). There are several things to take into account when choosing the scale factors. First, the scale factors are directly multiplied against the elements in the matrix. To prevent roundoff, each scale factor should be equal to an integer power of the number base of the machine. Since most machines operate in base two, scale factors should be a power of two. Second, the matrix should be scaled such that the matrix of element uncertainties is equilibrated. Third, this function multiplies the scale factors by the elements, so if one row tends to have uncertainties 1000 times smaller than the other rows, then its scale factor should be 1024, not 1/1024. Fourth, to save time, this function does not scale rows or columns if their scale factors are equal to one. Thus, the scale factors should be normalized to the most common scale factor. Rows and columns should be normalized separately. For example, if the size of the matrix is 100 and 10 rows tend to have uncertainties near 1e-6 and the remaining 90 have uncertainties near 1e-12, then the scale factor for the 10 should be 1/1,048,576 and the scale factors for the remaining 90 should be 1. Fifth, since this routine directly operates on the matrix, it is necessary to apply the scale factors to the RHS and Solution vectors. It may be easier to simply use <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>() on a scaled matrix to choose the pivoting order, and then throw away the matrix. Subsequent factorizations, performed with <a class="el" href="spMatrix_8h.html#a30">spFactor</a>(), will not need to have the RHS and Solution vectors descaled. Lastly, this function should not be executed before the function <a class="el" href="spMatrix_8h.html#a44">spMNA_Preorder</a>().<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix to be scaled. </td></tr>
<tr><td valign=top><em>SolutionScaleFactors</em>&nbsp;</td><td>
The array of Solution scale factors. These factors scale the columns. All scale factors are real valued. </td></tr>
<tr><td valign=top><em>RHS_ScaleFactors</em>&nbsp;</td><td>
The array of RHS scale factors. These factors scale the rows. All scale factors are real valued. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a52" doxytag="spMatrix.h::spSetComplex"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spSetComplex </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Forces matrix to be complex.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a53" doxytag="spMatrix.h::spSetReal"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spSetReal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Forces matrix to be real.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a60" doxytag="spMatrix.h::spSolve"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spSolve </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RHS</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Solution</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs forward elimination and back substitution to find the unknown vector from the <em>RHS</em> vector and factored matrix. This routine assumes that the pivots are associated with the lower triangular matrix and that the diagonal of the upper triangular matrix consists of ones. This routine arranges the computation in different way than is traditionally used in order to exploit the sparsity of the right-hand side. See the reference in spRevision.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
<tr><td valign=top><em>RHS</em>&nbsp;</td><td>
<em>RHS</em> is the input data array, the right hand side. This data is undisturbed and may be reused for other solves. </td></tr>
<tr><td valign=top><em>Solution</em>&nbsp;</td><td>
<em>Solution</em> is the output data array. This routine is constructed such that <em>RHS</em> and <em>Solution</em> can be the same array. </td></tr>
<tr><td valign=top><em>iRHS</em>&nbsp;</td><td>
<em>iRHS</em> is the imaginary portion of the input data array, the right hand side. This data is undisturbed and may be reused for other solves. This argument is only necessary if matrix is complex and if <em>spSEPARATED_COMPLEX_VECTOR</em> is set true. </td></tr>
<tr><td valign=top><em>iSolution</em>&nbsp;</td><td>
<em>iSolution</em> is the imaginary portion of the output data array. This routine is constructed such that <em>iRHS</em> and <em>iSolution</em> can be the same array. This argument is only necessary if matrix is complex and if <em>spSEPARATED_COMPLEX_VECTOR</em> is set true. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a61" doxytag="spMatrix.h::spSolveTransposed"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spSolveTransposed </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>RHS</em>[], </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>spREAL&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Solution</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs forward elimination and back substitution to find the unknown vector from the RHS vector and transposed factored matrix. This routine is useful when performing sensitivity analysis on a circuit using the adjoint method. This routine assumes that the pivots are associated with the untransposed lower triangular matrix and that the diagonal of the untransposed upper triangular matrix consists of ones.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to matrix. </td></tr>
<tr><td valign=top><em>RHS</em>&nbsp;</td><td>
<em>RHS</em> is the input data array, the right hand side. This data is undisturbed and may be reused for other solves. </td></tr>
<tr><td valign=top><em>Solution</em>&nbsp;</td><td>
<em>Solution</em> is the output data array. This routine is constructed such that <em>RHS</em> and <em>Solution</em> can be the same array. </td></tr>
<tr><td valign=top><em>iRHS</em>&nbsp;</td><td>
<em>iRHS</em> is the imaginary portion of the input data array, the right hand side. This data is undisturbed and may be reused for other solves. If <em>spSEPARATED_COMPLEX_VECTOR</em> is set false, or if matrix is real, there is no need to supply this array. </td></tr>
<tr><td valign=top><em>iSolution</em>&nbsp;</td><td>
<em>iSolution</em> is the imaginary portion of the output data array. This routine is constructed such that <em>iRHS</em> and <em>iSolution</em> can be the same array. If <em>spSEPARATED_COMPLEX_VECTOR</em> is set false, or if matrix is real, there is no need to supply this array. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a54" doxytag="spMatrix.h::spStripFills"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spStripFills </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>eMatrix</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Strips the matrix of all fill-ins.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
Pointer to the matrix to be stripped. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a55" doxytag="spMatrix.h::spWhereSingular"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> spcEXTERN void spWhereSingular </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="spMatrix_8h.html#a19">spMatrix</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>eMatrix</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pRow</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pCol</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the row and column number where the matrix was detected as singular (if pivoting was allowed on the last factorization) or where a zero was detected on the diagonal (if pivoting was not allowed on the last factorization). Pivoting is performed only in <a class="el" href="spMatrix_8h.html#a46">spOrderAndFactor</a>().<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>eMatrix</em>&nbsp;</td><td>
The matrix for which the error status is desired. </td></tr>
<tr><td valign=top><em>pRow</em>&nbsp;</td><td>
The row number. </td></tr>
<tr><td valign=top><em>pCol</em>&nbsp;</td><td>
The column number. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Mon Jun 30 12:01:28 2003 for Sparse by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.17 </small></address>
</body>
</html>
