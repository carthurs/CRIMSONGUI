<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>spConfig.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.17 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>spConfig.h File Reference</h1><code>#include &lt;limits.h&gt;</code><br>
<code>#include &lt;float.h&gt;</code><br>

<p>
<a href="spConfig_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a0">REAL</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a1">EXPANDABLE</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a2">TRANSLATE</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a3">INITIALIZE</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a4">DIAGONAL_PIVOTING</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a5">ARRAY_OFFSET</a>&nbsp;&nbsp;&nbsp;NOT FORTRAN</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a6">MODIFIED_MARKOWITZ</a>&nbsp;&nbsp;&nbsp;NO</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a7">DELETE</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a8">STRIP</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a9">MODIFIED_NODAL</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a10">QUAD_ELEMENT</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a11">TRANSPOSE</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a12">SCALING</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a13">DOCUMENTATION</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a14">MULTIPLICATION</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a15">DETERMINANT</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a16">STABILITY</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a17">CONDITION</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a18">PSEUDOCONDITION</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a19">FORTRAN</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a20">DEBUG</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a21">spCOMPLEX</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a22">spSEPARATED_COMPLEX_VECTORS</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a23">DEFAULT_THRESHOLD</a>&nbsp;&nbsp;&nbsp;1.0e-3</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a24">DIAG_PIVOTING_AS_DEFAULT</a>&nbsp;&nbsp;&nbsp;YES</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a25">SPACE_FOR_ELEMENTS</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a26">SPACE_FOR_FILL_INS</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a27">ELEMENTS_PER_ALLOCATION</a>&nbsp;&nbsp;&nbsp;31</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a28">MINIMUM_ALLOCATED_SIZE</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a29">EXPANSION_FACTOR</a>&nbsp;&nbsp;&nbsp;1.5</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a30">MAX_MARKOWITZ_TIES</a>&nbsp;&nbsp;&nbsp;100</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a31">TIES_MULTIPLIER</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a32">DEFAULT_PARTITION</a>&nbsp;&nbsp;&nbsp;spAUTO_PARTITION</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a33">PRINTER_WIDTH</a>&nbsp;&nbsp;&nbsp;80</td></tr>
<tr><td nowrap align=right valign=top><a name="a34" doxytag="spConfig.h::spcCONCAT"></a>
#define&nbsp;</td><td valign=bottom><b>spcCONCAT</b>(prefix, suffix)&nbsp;&nbsp;&nbsp;prefix/**/suffix</td></tr>
<tr><td nowrap align=right valign=top><a name="a35" doxytag="spConfig.h::spcQUOTE"></a>
#define&nbsp;</td><td valign=bottom><b>spcQUOTE</b>(x)&nbsp;&nbsp;&nbsp;"x"</td></tr>
<tr><td nowrap align=right valign=top><a name="a36" doxytag="spConfig.h::spcFUNC_NEEDS_FILE"></a>
#define&nbsp;</td><td valign=bottom><b>spcFUNC_NEEDS_FILE</b>(func, file)&nbsp;&nbsp;&nbsp;func/**/_requires_/**/file/**/_to_be_included_</td></tr>
<tr><td nowrap align=right valign=top><a name="a37" doxytag="spConfig.h::spcEXTERN"></a>
#define&nbsp;</td><td valign=bottom><b>spcEXTERN</b>&nbsp;&nbsp;&nbsp;extern</td></tr>
<tr><td nowrap align=right valign=top><a name="a38" doxytag="spConfig.h::spcNO_ARGS"></a>
#define&nbsp;</td><td valign=bottom><b>spcNO_ARGS</b></td></tr>
<tr><td nowrap align=right valign=top><a name="a39" doxytag="spConfig.h::spcCONST"></a>
#define&nbsp;</td><td valign=bottom><b>spcCONST</b></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a40">MACHINE_RESOLUTION</a>&nbsp;&nbsp;&nbsp;DBL_EPSILON</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a41">LARGEST_REAL</a>&nbsp;&nbsp;&nbsp;DBL_MAX</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a42">SMALLEST_REAL</a>&nbsp;&nbsp;&nbsp;DBL_MIN</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a43">LARGEST_SHORT_INTEGER</a>&nbsp;&nbsp;&nbsp;SHRT_MAX</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a44">LARGEST_LONG_INTEGER</a>&nbsp;&nbsp;&nbsp;LONG_MAX</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a45">ANNOTATE</a>&nbsp;&nbsp;&nbsp;NONE</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a46">NONE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a47">ON_STRANGE_BEHAVIOR</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="spConfig_8h.html#a48">FULL</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="a49" doxytag="spConfig.h::spGenericPtr"></a>
typedef char *&nbsp;</td><td valign=bottom><b>spGenericPtr</b></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
This file contains macros for the sparse matrix routines that are used to define the personality of the routines. The user is expected to modify this file to maximize the performance of the routines with his/her matrices.
<p>
Macros are distinguished by using solely capital letters in their identifiers. This contrasts with C defined identifiers which are strictly lower case, and program variable and procedure names which use both upper and lower case.
<p>
Objects that begin with the <em>spc</em> prefix are considered private and should not be used.
<p>
<dl compact><dt><b>Author: </b></dt><dd>
 Kenneth S. Kundert &lt;<a href="mailto:kundert@users.sourceforge.net">kundert@users.sourceforge.net</a>&gt;</dl><hr><h2>Define Documentation</h2>
<a name="a45" doxytag="spConfig.h::ANNOTATE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define ANNOTATE&nbsp;&nbsp;&nbsp;NONE
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro changes the amount of annotation produced by the matrix routines. The annotation is used as a debugging aid. Change the number associated with <em>ANNOTATE</em> to change the amount of annotation produced by the program. Possible values include <em>NONE</em>, <em>ON_STRANGE_BEHAVIOR</em>, and <em>FULL</em>. <em>NONE</em> is recommended.     </td>
  </tr>
</table>
<a name="a5" doxytag="spConfig.h::ARRAY_OFFSET"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define ARRAY_OFFSET&nbsp;&nbsp;&nbsp;NOT FORTRAN
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This determines whether arrays start at an index of zero or one. This option is necessitated by the fact that standard C convention dictates that arrays begin with an index of zero but the standard mathematic convention states that arrays begin with an index of one. So if you prefer to start your arrays with zero, or your calling Sparse from FORTRAN, set ARRAY_OFFSET to NO or 0. Otherwise, set ARRAY_OFFSET to YES or 1. Note that if you use an offset of one, the arrays that you pass to Sparse must have an allocated length of one plus the size of the matrix. ARRAY_OFFSET must be either 0 or 1, no other offsets are valid.     </td>
  </tr>
</table>
<a name="a17" doxytag="spConfig.h::CONDITION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CONDITION&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that <a class="el" href="spUtils_8c.html#a20">spCondition</a>() and <a class="el" href="spUtils_8c.html#a21">spNorm</a>(), the code that computes a good estimate of the condition number of the matrix, should be compiled. Recomend <em>NO</em>.     </td>
  </tr>
</table>
<a name="a20" doxytag="spConfig.h::DEBUG"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DEBUG&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that additional error checking will be compiled. The type of error checked are those that are common when the matrix routines are first integrated into a user's program. Once the routines have been integrated in and are running smoothly, this option should be turned off. <em>YES</em> is recommended.     </td>
  </tr>
</table>
<a name="a32" doxytag="spConfig.h::DEFAULT_PARTITION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DEFAULT_PARTITION&nbsp;&nbsp;&nbsp;spAUTO_PARTITION
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Which partition mode is used by <a class="el" href="spFactor_8c.html#a26">spPartition</a>() as default. Possibilities include <em>spDIRECT_PARTITION</em> (each row used direct addressing, best for a few relatively dense matrices), <em>spINDIRECT_PARTITION</em> (each row used indirect addressing, best for a few very sparse matrices), and <em>spAUTO_PARTITION</em> (direct or indirect addressing is chosen on a row-by-row basis, carries a large overhead, but speeds up both dense and sparse matrices, best if there is a large number of matrices that can use the same ordering.     </td>
  </tr>
</table>
<a name="a23" doxytag="spConfig.h::DEFAULT_THRESHOLD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DEFAULT_THRESHOLD&nbsp;&nbsp;&nbsp;1.0e-3
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The relative threshold used if the user enters an invalid threshold. Also the threshold used by <a class="el" href="spFactor_8c.html#a25">spFactor</a>() when calling <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>(). The default threshold should not be less than or equal to zero nor larger than one. 0.001 is recommended.     </td>
  </tr>
</table>
<a name="a7" doxytag="spConfig.h::DELETE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DELETE&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the <a class="el" href="spUtils_8c.html#a18">spDeleteRowAndCol</a>() routine should be compiled. Note that for this routine to be compiled, both <em>DELETE</em> and <em>TRANSLATE</em> should be set true.     </td>
  </tr>
</table>
<a name="a15" doxytag="spConfig.h::DETERMINANT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DETERMINANT&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the routine <a class="el" href="spUtils_8c.html#a16">spDeterminant</a>() should be complied.     </td>
  </tr>
</table>
<a name="a24" doxytag="spConfig.h::DIAG_PIVOTING_AS_DEFAULT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DIAG_PIVOTING_AS_DEFAULT&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This indicates whether <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>() should use diagonal pivoting as default. This issue only arises when <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>() is called from <a class="el" href="spFactor_8c.html#a25">spFactor</a>(). <em>YES</em> is recommended.     </td>
  </tr>
</table>
<a name="a4" doxytag="spConfig.h::DIAGONAL_PIVOTING"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DIAGONAL_PIVOTING&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Many matrices, and in particular node- and modified-node admittance matrices, tend to be nearly symmetric and nearly diagonally dominant. For these matrices, it is a good idea to select pivots from the diagonal. With this option enabled, this is exactly what happens, though if no satisfactory pivot can be found on the diagonal, an off-diagonal pivot will be used. If this option is disabled, Sparse does not preferentially search the diagonal. Because of this, Sparse has a wider variety of pivot candidates available, and so presumably fewer fill-ins will be created. However, the initial pivot selection process will take considerably longer. If working with node admittance matrices, or other matrices with a strong diagonal, it is probably best to use <em>DIAGONAL_PIVOTING</em> for two reasons. First, accuracy will be better because pivots will be chosen from the large diagonal elements, thus reducing the chance of growth. Second, a near optimal ordering will be chosen quickly. If the class of matrices you are working with does not have a strong diagonal, do not use <em>DIAGONAL_PIVOTING</em>, but consider using a larger threshold. When <em>DIAGONAL_PIVOTING</em> is turned off, the following options and constants are not used: <em>MODIFIED_MARKOWITZ</em>, <em>MAX_MARKOWITZ_TIES</em>, and <em>TIES_MULTIPLIER</em>.     </td>
  </tr>
</table>
<a name="a13" doxytag="spConfig.h::DOCUMENTATION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DOCUMENTATION&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that routines that are used to document the matrix, such as <a class="el" href="spOutput_8c.html#a3">spPrint</a>() and <a class="el" href="spOutput_8c.html#a4">spFileMatrix</a>(), should be compiled.     </td>
  </tr>
</table>
<a name="a27" doxytag="spConfig.h::ELEMENTS_PER_ALLOCATION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define ELEMENTS_PER_ALLOCATION&nbsp;&nbsp;&nbsp;31
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The number of matrix elements requested from the malloc utility on each call to it. Setting this value greater than 1 reduces the amount of overhead spent in this system call. On a virtual memory machine, its good to allocate slightly less than a page worth of elements at a time (or some multiple thereof). 31 is recommended.     </td>
  </tr>
</table>
<a name="a1" doxytag="spConfig.h::EXPANDABLE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define EXPANDABLE&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setting this compiler flag true (1) makes the matrix expandable before it has been factored. If the matrix is expandable, then if an element is added that would be considered out of bounds in the current matrix, the size of the matrix is increased to hold that element. As a result, the size of the matrix need not be known before the matrix is built. The matrix can be allocated with size zero and expanded.     </td>
  </tr>
</table>
<a name="a29" doxytag="spConfig.h::EXPANSION_FACTOR"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define EXPANSION_FACTOR&nbsp;&nbsp;&nbsp;1.5
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The amount the allocated size of the matrix is increased when it is expanded.     </td>
  </tr>
</table>
<a name="a19" doxytag="spConfig.h::FORTRAN"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define FORTRAN&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the <em>FORTRAN</em> interface routines should be compiled. When interfacing to <em>FORTRAN</em> programs, the <em>ARRAY_OFFSET</em> options should be set to NO.     </td>
  </tr>
</table>
<a name="a48" doxytag="spConfig.h::FULL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define FULL&nbsp;&nbsp;&nbsp;2
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A possible value for <em>ANNOTATE</em>. Enables full annotation.     </td>
  </tr>
</table>
<a name="a3" doxytag="spConfig.h::INITIALIZE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define INITIALIZE&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Causes the <a class="el" href="spBuild_8c.html#a21">spInitialize</a>(), <a class="el" href="spBuild_8c.html#a23">spGetInitInfo</a>(), and <a class="el" href="spBuild_8c.html#a22">spInstallInitInfo</a>() routines to be compiled. These routines allow the user to store and read one pointer in each nonzero element in the matrix. <a class="el" href="spBuild_8c.html#a21">spInitialize</a>() then calls a user specified function for each structural nonzero in the matrix, and includes this pointer as well as the external row and column numbers as arguments. This allows the user to write custom matrix initialization routines.     </td>
  </tr>
</table>
<a name="a44" doxytag="spConfig.h::LARGEST_LONG_INTEGER"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define LARGEST_LONG_INTEGER&nbsp;&nbsp;&nbsp;LONG_MAX
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The largest possible value of longs.     </td>
  </tr>
</table>
<a name="a41" doxytag="spConfig.h::LARGEST_REAL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define LARGEST_REAL&nbsp;&nbsp;&nbsp;DBL_MAX
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The largest possible value of spREAL.     </td>
  </tr>
</table>
<a name="a43" doxytag="spConfig.h::LARGEST_SHORT_INTEGER"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define LARGEST_SHORT_INTEGER&nbsp;&nbsp;&nbsp;SHRT_MAX
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The largest possible value of shorts.     </td>
  </tr>
</table>
<a name="a40" doxytag="spConfig.h::MACHINE_RESOLUTION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MACHINE_RESOLUTION&nbsp;&nbsp;&nbsp;DBL_EPSILON
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The resolution of spREAL.     </td>
  </tr>
</table>
<a name="a30" doxytag="spConfig.h::MAX_MARKOWITZ_TIES"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MAX_MARKOWITZ_TIES&nbsp;&nbsp;&nbsp;100
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Some terminology should be defined. The Markowitz row count is the number of non-zero elements in a row excluding the one being considered as pivot. There is one Markowitz row count for every row. The Markowitz column is defined similarly for columns. The Markowitz product for an element is the product of its row and column counts. It is a measure of how much work would be required on the next step of the factorization if that element were chosen to be pivot. A small Markowitz product is desirable.
<p>
This number is used for two slightly different things, both of which relate to the search for the best pivot. First, it is the maximum number of elements that are Markowitz tied that will be sifted through when trying to find the one that is numerically the best. Second, it creates an upper bound on how large a Markowitz product can be before it eliminates the possibility of early termination of the pivot search. In other words, if the product of the smallest Markowitz product yet found and <em>TIES_MULTIPLIER</em> is greater than <em>MAX_MARKOWITZ_TIES</em>, then no early termination takes place. Set <em>MAX_MARKOWITZ_TIES</em> to some small value if no early termination of the pivot search is desired. An array of RealNumbers is allocated of size <em>MAX_MARKOWITZ_TIES</em> so it must be positive and shouldn't be too large. Active when MODIFIED_MARKOWITZ is 1 (YES). 100 is recommended. <dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spConfig_8h.html#a31">TIES_MULTIPLIER</a> </dl>    </td>
  </tr>
</table>
<a name="a28" doxytag="spConfig.h::MINIMUM_ALLOCATED_SIZE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MINIMUM_ALLOCATED_SIZE&nbsp;&nbsp;&nbsp;6
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The minimum allocated size of a matrix. Note that this does not limit the minimum size of a matrix. This just prevents having to resize a matrix many times if the matrix is expandable, large and allocated with an estimated size of zero. This number should not be less than one.     </td>
  </tr>
</table>
<a name="a6" doxytag="spConfig.h::MODIFIED_MARKOWITZ"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MODIFIED_MARKOWITZ&nbsp;&nbsp;&nbsp;NO
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the modified Markowitz method of pivot selection is to be used. The modified Markowitz method differs from standard Markowitz in two ways. First, under modified Markowitz, the search for a pivot can be terminated early if a adequate (in terms of sparsity) pivot candidate is found. Thus, when using modified Markowitz, the initial factorization can be faster, but at the expense of a suboptimal pivoting order that may slow subsequent factorizations. The second difference is in the way modified Markowitz breaks Markowitz ties. When two or more elements are pivot candidates and they all have the same Markowitz product, then the tie is broken by choosing the element that is best numerically. The numerically best element is the one with the largest ratio of its magnitude to the magnitude of the largest element in the same column, excluding itself. The modified Markowitz method results in marginally better accuracy. This option is most appropriate for use when working with very large matrices where the initial factor time represents an unacceptable burden. <em>NO</em> is recommended.     </td>
  </tr>
</table>
<a name="a9" doxytag="spConfig.h::MODIFIED_NODAL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MODIFIED_NODAL&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the routine that preorders modified node admittance matrices should be compiled. This routine results in greater speed and accuracy if used with this type of matrix.     </td>
  </tr>
</table>
<a name="a14" doxytag="spConfig.h::MULTIPLICATION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MULTIPLICATION&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that routines that are used to multily the matrix by a vector, such as <a class="el" href="spUtils_8c.html#a14">spMultiply</a>() and <a class="el" href="spUtils_8c.html#a15">spMultTransposed</a>(), should be compiled.     </td>
  </tr>
</table>
<a name="a46" doxytag="spConfig.h::NONE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define NONE&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A possible value for <em>ANNOTATE</em>. Disables all annotation.     </td>
  </tr>
</table>
<a name="a47" doxytag="spConfig.h::ON_STRANGE_BEHAVIOR"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define ON_STRANGE_BEHAVIOR&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A possible value for <em>ANNOTATE</em>. Causes annotation to be produce upon unusual occurances only.     </td>
  </tr>
</table>
<a name="a33" doxytag="spConfig.h::PRINTER_WIDTH"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PRINTER_WIDTH&nbsp;&nbsp;&nbsp;80
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The number of characters per page width. Set to 80 for terminal, 132 for line printer. Controls how many columns printed by <a class="el" href="spOutput_8c.html#a3">spPrint</a>() per page width.     </td>
  </tr>
</table>
<a name="a18" doxytag="spConfig.h::PSEUDOCONDITION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PSEUDOCONDITION&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that <a class="el" href="spUtils_8c.html#a19">spPseudoCondition</a>(), the code that computes a crude and easily fooled indicator of ill-conditioning in the matrix, should be compiled. Recomend <em>NO</em>.     </td>
  </tr>
</table>
<a name="a10" doxytag="spConfig.h::QUAD_ELEMENT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define QUAD_ELEMENT&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the routines that allow four related elements to be entered into the matrix at once should be compiled. These elements are usually related to an admittance. The routines affected by <em>QUAD_ELEMENT</em> are the <a class="el" href="spBuild_8c.html#a13">spGetAdmittance</a>(), <a class="el" href="spBuild_8c.html#a14">spGetQuad</a>() and <a class="el" href="spBuild_8c.html#a15">spGetOnes</a>() routines.     </td>
  </tr>
</table>
<a name="a0" doxytag="spConfig.h::REAL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define REAL&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the routines are expected to handle real systems of equations. The routines can be compiled to handle both real and complex systems at the same time, but there is a slight speed and memory advantage if the routines are complied to handle only real systems of equations.     </td>
  </tr>
</table>
<a name="a12" doxytag="spConfig.h::SCALING"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SCALING&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the routine that performs scaling on the matrix should be complied. Scaling is not strongly supported. The routine to scale the matrix is provided, but no routines are provided to scale and descale the RHS and Solution vectors. It is suggested that if scaling is desired, it only be preformed when the pivot order is being chosen [in <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>()]. This is the only time scaling has an effect. The scaling may then either be removed from the solution by the user or the scaled factors may simply be thrown away. <em>NO</em> is recommended.     </td>
  </tr>
</table>
<a name="a42" doxytag="spConfig.h::SMALLEST_REAL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SMALLEST_REAL&nbsp;&nbsp;&nbsp;DBL_MIN
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The smalles possible positive value of spREAL.     </td>
  </tr>
</table>
<a name="a25" doxytag="spConfig.h::SPACE_FOR_ELEMENTS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SPACE_FOR_ELEMENTS&nbsp;&nbsp;&nbsp;6
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This number multiplied by the size of the matrix equals the number of elements for which memory is initially allocated in <a class="el" href="spAllocate_8c.html#a11">spCreate</a>(). 6 is recommended.     </td>
  </tr>
</table>
<a name="a26" doxytag="spConfig.h::SPACE_FOR_FILL_INS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SPACE_FOR_FILL_INS&nbsp;&nbsp;&nbsp;4
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This number multiplied by the size of the matrix equals the number of elements for which memory is initially allocated and specifically reserved for fill-ins in <a class="el" href="spAllocate_8c.html#a11">spCreate</a>(). 4 is recommended.     </td>
  </tr>
</table>
<a name="a21" doxytag="spConfig.h::spCOMPLEX"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spCOMPLEX&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the routines will be complied to handle complex systems of equations.     </td>
  </tr>
</table>
<a name="a22" doxytag="spConfig.h::spSEPARATED_COMPLEX_VECTORS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define spSEPARATED_COMPLEX_VECTORS&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies the format for complex vectors. If this is set false then a complex vector is made up of one double sized array of RealNumber's in which the real and imaginary numbers are placed alternately in the array. In other words, the first entry would be Complex[1].Real, then comes Complex[1].Imag, then Complex[2].Real, etc. If <em>spSEPARATED_COMPLEX_VECTORS</em> is set true, then each complex vector is represented by two arrays of <em>spREALs</em>, one with the real terms, the other with the imaginary. <em>NO</em> is recommended.     </td>
  </tr>
</table>
<a name="a16" doxytag="spConfig.h::STABILITY"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define STABILITY&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that <a class="el" href="spUtils_8c.html#a22">spLargestElement</a>() and <a class="el" href="spUtils_8c.html#a23">spRoundoff</a>() should be compiled. These routines are used to check the stability (and hence the quality of the pivoting) of the factorization by computing a bound on the size of the element is the matrix <img align="top" src="form_22.png">
. If this bound is very high after applying <a class="el" href="spFactor_8c.html#a24">spOrderAndFactor</a>(), then the pivot threshold should be raised. If the bound increases greatly after using <a class="el" href="spFactor_8c.html#a25">spFactor</a>(), then the matrix should probably be reordered. Recomend <em>NO</em>.     </td>
  </tr>
</table>
<a name="a8" doxytag="spConfig.h::STRIP"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define STRIP&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the <a class="el" href="spUtils_8c.html#a17">spStripFills</a>() routine should be compiled.     </td>
  </tr>
</table>
<a name="a31" doxytag="spConfig.h::TIES_MULTIPLIER"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define TIES_MULTIPLIER&nbsp;&nbsp;&nbsp;5
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specifies the number of Markowitz ties that are allowed to occur before the search for the pivot is terminated early. Set to some large value if no early termination of the pivot search is desired. This number is multiplied times the Markowitz product to determine how many ties are required for early termination. This means that more elements will be searched before early termination if a large number of fill-ins could be created by accepting what is currently considered the best choice for the pivot. Active when <em>MODIFIED_MARKOWITZ</em> is 1 (YES). Setting this number to zero effectively eliminates all pivoting, which should be avoided. This number must be positive. <em>TIES_MULTIPLIER</em> is also used when diagonal pivoting breaks down. 5 is recommended. <dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="spConfig_8h.html#a30">MAX_MARKOWITZ_TIES</a> </dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="spConfig.h::TRANSLATE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define TRANSLATE&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This option allows the set of external row and column numbers to be non-packed. In other words, the row and column numbers do not have to be contiguous. The priced paid for this flexibility is that when <em>TRANSLATE</em> is set true, the time required to initially build the matrix will be greater because the external row and column number must be translated into internal equivalents. This translation brings about other benefits though. First, the <a class="el" href="spBuild_8c.html#a12">spGetElement</a>() and <a class="el" href="spBuild_8c.html#a13">spGetAdmittance</a>() routines may be used after the matrix has been factored. Further, elements, and even rows and columns, may be added to the matrix, and row and columns may be deleted from the matrix, after it has been factored. Note that when the set of row and column number is not a packed set, neither are the <em>RHS</em> and <em>Solution</em> vectors. Thus the size of these vectors must be at least as large as the external size, which is the value of the largest given row or column numbers.     </td>
  </tr>
</table>
<a name="a11" doxytag="spConfig.h::TRANSPOSE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define TRANSPOSE&nbsp;&nbsp;&nbsp;YES
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This specifies that the routines that solve the matrix as if it was transposed should be compiled. These routines are useful when performing sensitivity analysis using the adjoint method.     </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Mon Jun 30 12:01:27 2003 for Sparse by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.17 </small></address>
</body>
</html>
